
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model blocks
 * 
 */
export type blocks = $Result.DefaultSelection<Prisma.$blocksPayload>
/**
 * Model d_account
 * 
 */
export type d_account = $Result.DefaultSelection<Prisma.$d_accountPayload>
/**
 * Model d_block
 * 
 */
export type d_block = $Result.DefaultSelection<Prisma.$d_blockPayload>
/**
 * Model d_date
 * 
 */
export type d_date = $Result.DefaultSelection<Prisma.$d_datePayload>
/**
 * Model d_time
 * 
 */
export type d_time = $Result.DefaultSelection<Prisma.$d_timePayload>
/**
 * Model d_transaction
 * 
 */
export type d_transaction = $Result.DefaultSelection<Prisma.$d_transactionPayload>
/**
 * Model token_transfers
 * 
 */
export type token_transfers = $Result.DefaultSelection<Prisma.$token_transfersPayload>
/**
 * Model transactions
 * 
 */
export type transactions = $Result.DefaultSelection<Prisma.$transactionsPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Blocks
 * const blocks = await prisma.blocks.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Blocks
   * const blocks = await prisma.blocks.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.blocks`: Exposes CRUD operations for the **blocks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blocks
    * const blocks = await prisma.blocks.findMany()
    * ```
    */
  get blocks(): Prisma.blocksDelegate<ExtArgs>;

  /**
   * `prisma.d_account`: Exposes CRUD operations for the **d_account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more D_accounts
    * const d_accounts = await prisma.d_account.findMany()
    * ```
    */
  get d_account(): Prisma.d_accountDelegate<ExtArgs>;

  /**
   * `prisma.d_block`: Exposes CRUD operations for the **d_block** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more D_blocks
    * const d_blocks = await prisma.d_block.findMany()
    * ```
    */
  get d_block(): Prisma.d_blockDelegate<ExtArgs>;

  /**
   * `prisma.d_date`: Exposes CRUD operations for the **d_date** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more D_dates
    * const d_dates = await prisma.d_date.findMany()
    * ```
    */
  get d_date(): Prisma.d_dateDelegate<ExtArgs>;

  /**
   * `prisma.d_time`: Exposes CRUD operations for the **d_time** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more D_times
    * const d_times = await prisma.d_time.findMany()
    * ```
    */
  get d_time(): Prisma.d_timeDelegate<ExtArgs>;

  /**
   * `prisma.d_transaction`: Exposes CRUD operations for the **d_transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more D_transactions
    * const d_transactions = await prisma.d_transaction.findMany()
    * ```
    */
  get d_transaction(): Prisma.d_transactionDelegate<ExtArgs>;

  /**
   * `prisma.token_transfers`: Exposes CRUD operations for the **token_transfers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Token_transfers
    * const token_transfers = await prisma.token_transfers.findMany()
    * ```
    */
  get token_transfers(): Prisma.token_transfersDelegate<ExtArgs>;

  /**
   * `prisma.transactions`: Exposes CRUD operations for the **transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transactions.findMany()
    * ```
    */
  get transactions(): Prisma.transactionsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.1.1
   * Query Engine version: 6a3747c37ff169c90047725a05a6ef02e32ac97e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    blocks: 'blocks',
    d_account: 'd_account',
    d_block: 'd_block',
    d_date: 'd_date',
    d_time: 'd_time',
    d_transaction: 'd_transaction',
    token_transfers: 'token_transfers',
    transactions: 'transactions'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'blocks' | 'd_account' | 'd_block' | 'd_date' | 'd_time' | 'd_transaction' | 'token_transfers' | 'transactions'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      blocks: {
        payload: Prisma.$blocksPayload<ExtArgs>
        fields: Prisma.blocksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.blocksFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blocksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.blocksFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          findFirst: {
            args: Prisma.blocksFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blocksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.blocksFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          findMany: {
            args: Prisma.blocksFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>[]
          }
          create: {
            args: Prisma.blocksCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          createMany: {
            args: Prisma.blocksCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.blocksDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          update: {
            args: Prisma.blocksUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          deleteMany: {
            args: Prisma.blocksDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.blocksUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.blocksUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$blocksPayload>
          }
          aggregate: {
            args: Prisma.BlocksAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBlocks>
          }
          groupBy: {
            args: Prisma.blocksGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BlocksGroupByOutputType>[]
          }
          count: {
            args: Prisma.blocksCountArgs<ExtArgs>,
            result: $Utils.Optional<BlocksCountAggregateOutputType> | number
          }
        }
      }
      d_account: {
        payload: Prisma.$d_accountPayload<ExtArgs>
        fields: Prisma.d_accountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.d_accountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_accountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.d_accountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_accountPayload>
          }
          findFirst: {
            args: Prisma.d_accountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_accountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.d_accountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_accountPayload>
          }
          findMany: {
            args: Prisma.d_accountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_accountPayload>[]
          }
          create: {
            args: Prisma.d_accountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_accountPayload>
          }
          createMany: {
            args: Prisma.d_accountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.d_accountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_accountPayload>
          }
          update: {
            args: Prisma.d_accountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_accountPayload>
          }
          deleteMany: {
            args: Prisma.d_accountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.d_accountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.d_accountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_accountPayload>
          }
          aggregate: {
            args: Prisma.D_accountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateD_account>
          }
          groupBy: {
            args: Prisma.d_accountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<D_accountGroupByOutputType>[]
          }
          count: {
            args: Prisma.d_accountCountArgs<ExtArgs>,
            result: $Utils.Optional<D_accountCountAggregateOutputType> | number
          }
        }
      }
      d_block: {
        payload: Prisma.$d_blockPayload<ExtArgs>
        fields: Prisma.d_blockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.d_blockFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_blockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.d_blockFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_blockPayload>
          }
          findFirst: {
            args: Prisma.d_blockFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_blockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.d_blockFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_blockPayload>
          }
          findMany: {
            args: Prisma.d_blockFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_blockPayload>[]
          }
          create: {
            args: Prisma.d_blockCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_blockPayload>
          }
          createMany: {
            args: Prisma.d_blockCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.d_blockDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_blockPayload>
          }
          update: {
            args: Prisma.d_blockUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_blockPayload>
          }
          deleteMany: {
            args: Prisma.d_blockDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.d_blockUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.d_blockUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_blockPayload>
          }
          aggregate: {
            args: Prisma.D_blockAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateD_block>
          }
          groupBy: {
            args: Prisma.d_blockGroupByArgs<ExtArgs>,
            result: $Utils.Optional<D_blockGroupByOutputType>[]
          }
          count: {
            args: Prisma.d_blockCountArgs<ExtArgs>,
            result: $Utils.Optional<D_blockCountAggregateOutputType> | number
          }
        }
      }
      d_date: {
        payload: Prisma.$d_datePayload<ExtArgs>
        fields: Prisma.d_dateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.d_dateFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_datePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.d_dateFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_datePayload>
          }
          findFirst: {
            args: Prisma.d_dateFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_datePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.d_dateFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_datePayload>
          }
          findMany: {
            args: Prisma.d_dateFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_datePayload>[]
          }
          create: {
            args: Prisma.d_dateCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_datePayload>
          }
          createMany: {
            args: Prisma.d_dateCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.d_dateDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_datePayload>
          }
          update: {
            args: Prisma.d_dateUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_datePayload>
          }
          deleteMany: {
            args: Prisma.d_dateDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.d_dateUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.d_dateUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_datePayload>
          }
          aggregate: {
            args: Prisma.D_dateAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateD_date>
          }
          groupBy: {
            args: Prisma.d_dateGroupByArgs<ExtArgs>,
            result: $Utils.Optional<D_dateGroupByOutputType>[]
          }
          count: {
            args: Prisma.d_dateCountArgs<ExtArgs>,
            result: $Utils.Optional<D_dateCountAggregateOutputType> | number
          }
        }
      }
      d_time: {
        payload: Prisma.$d_timePayload<ExtArgs>
        fields: Prisma.d_timeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.d_timeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_timePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.d_timeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_timePayload>
          }
          findFirst: {
            args: Prisma.d_timeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_timePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.d_timeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_timePayload>
          }
          findMany: {
            args: Prisma.d_timeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_timePayload>[]
          }
          create: {
            args: Prisma.d_timeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_timePayload>
          }
          createMany: {
            args: Prisma.d_timeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.d_timeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_timePayload>
          }
          update: {
            args: Prisma.d_timeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_timePayload>
          }
          deleteMany: {
            args: Prisma.d_timeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.d_timeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.d_timeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_timePayload>
          }
          aggregate: {
            args: Prisma.D_timeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateD_time>
          }
          groupBy: {
            args: Prisma.d_timeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<D_timeGroupByOutputType>[]
          }
          count: {
            args: Prisma.d_timeCountArgs<ExtArgs>,
            result: $Utils.Optional<D_timeCountAggregateOutputType> | number
          }
        }
      }
      d_transaction: {
        payload: Prisma.$d_transactionPayload<ExtArgs>
        fields: Prisma.d_transactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.d_transactionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_transactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.d_transactionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_transactionPayload>
          }
          findFirst: {
            args: Prisma.d_transactionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_transactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.d_transactionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_transactionPayload>
          }
          findMany: {
            args: Prisma.d_transactionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_transactionPayload>[]
          }
          create: {
            args: Prisma.d_transactionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_transactionPayload>
          }
          createMany: {
            args: Prisma.d_transactionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.d_transactionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_transactionPayload>
          }
          update: {
            args: Prisma.d_transactionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_transactionPayload>
          }
          deleteMany: {
            args: Prisma.d_transactionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.d_transactionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.d_transactionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$d_transactionPayload>
          }
          aggregate: {
            args: Prisma.D_transactionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateD_transaction>
          }
          groupBy: {
            args: Prisma.d_transactionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<D_transactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.d_transactionCountArgs<ExtArgs>,
            result: $Utils.Optional<D_transactionCountAggregateOutputType> | number
          }
        }
      }
      token_transfers: {
        payload: Prisma.$token_transfersPayload<ExtArgs>
        fields: Prisma.token_transfersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.token_transfersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$token_transfersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.token_transfersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$token_transfersPayload>
          }
          findFirst: {
            args: Prisma.token_transfersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$token_transfersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.token_transfersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$token_transfersPayload>
          }
          findMany: {
            args: Prisma.token_transfersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$token_transfersPayload>[]
          }
          create: {
            args: Prisma.token_transfersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$token_transfersPayload>
          }
          createMany: {
            args: Prisma.token_transfersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.token_transfersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$token_transfersPayload>
          }
          update: {
            args: Prisma.token_transfersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$token_transfersPayload>
          }
          deleteMany: {
            args: Prisma.token_transfersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.token_transfersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.token_transfersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$token_transfersPayload>
          }
          aggregate: {
            args: Prisma.Token_transfersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateToken_transfers>
          }
          groupBy: {
            args: Prisma.token_transfersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Token_transfersGroupByOutputType>[]
          }
          count: {
            args: Prisma.token_transfersCountArgs<ExtArgs>,
            result: $Utils.Optional<Token_transfersCountAggregateOutputType> | number
          }
        }
      }
      transactions: {
        payload: Prisma.$transactionsPayload<ExtArgs>
        fields: Prisma.transactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transactionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transactionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          findFirst: {
            args: Prisma.transactionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transactionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          findMany: {
            args: Prisma.transactionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>[]
          }
          create: {
            args: Prisma.transactionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          createMany: {
            args: Prisma.transactionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.transactionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          update: {
            args: Prisma.transactionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          deleteMany: {
            args: Prisma.transactionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.transactionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.transactionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          aggregate: {
            args: Prisma.TransactionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTransactions>
          }
          groupBy: {
            args: Prisma.transactionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TransactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.transactionsCountArgs<ExtArgs>,
            result: $Utils.Optional<TransactionsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model blocks
   */

  export type AggregateBlocks = {
    _count: BlocksCountAggregateOutputType | null
    _avg: BlocksAvgAggregateOutputType | null
    _sum: BlocksSumAggregateOutputType | null
    _min: BlocksMinAggregateOutputType | null
    _max: BlocksMaxAggregateOutputType | null
  }

  export type BlocksAvgAggregateOutputType = {
    number: number | null
    proposer_index: number | null
    gas_limit: number | null
    gas_used: number | null
    transaction_count: number | null
  }

  export type BlocksSumAggregateOutputType = {
    number: bigint | null
    proposer_index: bigint | null
    gas_limit: bigint | null
    gas_used: bigint | null
    transaction_count: bigint | null
  }

  export type BlocksMinAggregateOutputType = {
    number: bigint | null
    hash: string | null
    parent_hash: string | null
    nonce: string | null
    logs_bloom: string | null
    transactions_root: string | null
    state_root: string | null
    receipts_root: string | null
    fee_recipient: string | null
    proposer_index: bigint | null
    gas_limit: bigint | null
    gas_used: bigint | null
    timestamp: Date | null
    transaction_count: bigint | null
  }

  export type BlocksMaxAggregateOutputType = {
    number: bigint | null
    hash: string | null
    parent_hash: string | null
    nonce: string | null
    logs_bloom: string | null
    transactions_root: string | null
    state_root: string | null
    receipts_root: string | null
    fee_recipient: string | null
    proposer_index: bigint | null
    gas_limit: bigint | null
    gas_used: bigint | null
    timestamp: Date | null
    transaction_count: bigint | null
  }

  export type BlocksCountAggregateOutputType = {
    number: number
    hash: number
    parent_hash: number
    nonce: number
    logs_bloom: number
    transactions_root: number
    state_root: number
    receipts_root: number
    fee_recipient: number
    proposer_index: number
    gas_limit: number
    gas_used: number
    timestamp: number
    transaction_count: number
    _all: number
  }


  export type BlocksAvgAggregateInputType = {
    number?: true
    proposer_index?: true
    gas_limit?: true
    gas_used?: true
    transaction_count?: true
  }

  export type BlocksSumAggregateInputType = {
    number?: true
    proposer_index?: true
    gas_limit?: true
    gas_used?: true
    transaction_count?: true
  }

  export type BlocksMinAggregateInputType = {
    number?: true
    hash?: true
    parent_hash?: true
    nonce?: true
    logs_bloom?: true
    transactions_root?: true
    state_root?: true
    receipts_root?: true
    fee_recipient?: true
    proposer_index?: true
    gas_limit?: true
    gas_used?: true
    timestamp?: true
    transaction_count?: true
  }

  export type BlocksMaxAggregateInputType = {
    number?: true
    hash?: true
    parent_hash?: true
    nonce?: true
    logs_bloom?: true
    transactions_root?: true
    state_root?: true
    receipts_root?: true
    fee_recipient?: true
    proposer_index?: true
    gas_limit?: true
    gas_used?: true
    timestamp?: true
    transaction_count?: true
  }

  export type BlocksCountAggregateInputType = {
    number?: true
    hash?: true
    parent_hash?: true
    nonce?: true
    logs_bloom?: true
    transactions_root?: true
    state_root?: true
    receipts_root?: true
    fee_recipient?: true
    proposer_index?: true
    gas_limit?: true
    gas_used?: true
    timestamp?: true
    transaction_count?: true
    _all?: true
  }

  export type BlocksAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which blocks to aggregate.
     */
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blocks
    **/
    _count?: true | BlocksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlocksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlocksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlocksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlocksMaxAggregateInputType
  }

  export type GetBlocksAggregateType<T extends BlocksAggregateArgs> = {
        [P in keyof T & keyof AggregateBlocks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlocks[P]>
      : GetScalarType<T[P], AggregateBlocks[P]>
  }




  export type blocksGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: blocksWhereInput
    orderBy?: blocksOrderByWithAggregationInput | blocksOrderByWithAggregationInput[]
    by: BlocksScalarFieldEnum[] | BlocksScalarFieldEnum
    having?: blocksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlocksCountAggregateInputType | true
    _avg?: BlocksAvgAggregateInputType
    _sum?: BlocksSumAggregateInputType
    _min?: BlocksMinAggregateInputType
    _max?: BlocksMaxAggregateInputType
  }

  export type BlocksGroupByOutputType = {
    number: bigint | null
    hash: string
    parent_hash: string | null
    nonce: string | null
    logs_bloom: string | null
    transactions_root: string | null
    state_root: string | null
    receipts_root: string | null
    fee_recipient: string | null
    proposer_index: bigint | null
    gas_limit: bigint | null
    gas_used: bigint | null
    timestamp: Date | null
    transaction_count: bigint | null
    _count: BlocksCountAggregateOutputType | null
    _avg: BlocksAvgAggregateOutputType | null
    _sum: BlocksSumAggregateOutputType | null
    _min: BlocksMinAggregateOutputType | null
    _max: BlocksMaxAggregateOutputType | null
  }

  type GetBlocksGroupByPayload<T extends blocksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlocksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlocksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlocksGroupByOutputType[P]>
            : GetScalarType<T[P], BlocksGroupByOutputType[P]>
        }
      >
    >


  export type blocksSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    number?: boolean
    hash?: boolean
    parent_hash?: boolean
    nonce?: boolean
    logs_bloom?: boolean
    transactions_root?: boolean
    state_root?: boolean
    receipts_root?: boolean
    fee_recipient?: boolean
    proposer_index?: boolean
    gas_limit?: boolean
    gas_used?: boolean
    timestamp?: boolean
    transaction_count?: boolean
  }, ExtArgs["result"]["blocks"]>

  export type blocksSelectScalar = {
    number?: boolean
    hash?: boolean
    parent_hash?: boolean
    nonce?: boolean
    logs_bloom?: boolean
    transactions_root?: boolean
    state_root?: boolean
    receipts_root?: boolean
    fee_recipient?: boolean
    proposer_index?: boolean
    gas_limit?: boolean
    gas_used?: boolean
    timestamp?: boolean
    transaction_count?: boolean
  }


  export type $blocksPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "blocks"
    objects: {}
    scalars: $Extensions.GetResult<{
      number: bigint | null
      hash: string
      parent_hash: string | null
      nonce: string | null
      logs_bloom: string | null
      transactions_root: string | null
      state_root: string | null
      receipts_root: string | null
      fee_recipient: string | null
      proposer_index: bigint | null
      gas_limit: bigint | null
      gas_used: bigint | null
      timestamp: Date | null
      transaction_count: bigint | null
    }, ExtArgs["result"]["blocks"]>
    composites: {}
  }


  type blocksGetPayload<S extends boolean | null | undefined | blocksDefaultArgs> = $Result.GetResult<Prisma.$blocksPayload, S>

  type blocksCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<blocksFindManyArgs, 'select' | 'include'> & {
      select?: BlocksCountAggregateInputType | true
    }

  export interface blocksDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['blocks'], meta: { name: 'blocks' } }
    /**
     * Find zero or one Blocks that matches the filter.
     * @param {blocksFindUniqueArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends blocksFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, blocksFindUniqueArgs<ExtArgs>>
    ): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Blocks that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {blocksFindUniqueOrThrowArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends blocksFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, blocksFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksFindFirstArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends blocksFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, blocksFindFirstArgs<ExtArgs>>
    ): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Blocks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksFindFirstOrThrowArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends blocksFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, blocksFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blocks
     * const blocks = await prisma.blocks.findMany()
     * 
     * // Get first 10 Blocks
     * const blocks = await prisma.blocks.findMany({ take: 10 })
     * 
     * // Only select the `number`
     * const blocksWithNumberOnly = await prisma.blocks.findMany({ select: { number: true } })
     * 
    **/
    findMany<T extends blocksFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, blocksFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Blocks.
     * @param {blocksCreateArgs} args - Arguments to create a Blocks.
     * @example
     * // Create one Blocks
     * const Blocks = await prisma.blocks.create({
     *   data: {
     *     // ... data to create a Blocks
     *   }
     * })
     * 
    **/
    create<T extends blocksCreateArgs<ExtArgs>>(
      args: SelectSubset<T, blocksCreateArgs<ExtArgs>>
    ): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Blocks.
     *     @param {blocksCreateManyArgs} args - Arguments to create many Blocks.
     *     @example
     *     // Create many Blocks
     *     const blocks = await prisma.blocks.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends blocksCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, blocksCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Blocks.
     * @param {blocksDeleteArgs} args - Arguments to delete one Blocks.
     * @example
     * // Delete one Blocks
     * const Blocks = await prisma.blocks.delete({
     *   where: {
     *     // ... filter to delete one Blocks
     *   }
     * })
     * 
    **/
    delete<T extends blocksDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, blocksDeleteArgs<ExtArgs>>
    ): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Blocks.
     * @param {blocksUpdateArgs} args - Arguments to update one Blocks.
     * @example
     * // Update one Blocks
     * const blocks = await prisma.blocks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends blocksUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, blocksUpdateArgs<ExtArgs>>
    ): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Blocks.
     * @param {blocksDeleteManyArgs} args - Arguments to filter Blocks to delete.
     * @example
     * // Delete a few Blocks
     * const { count } = await prisma.blocks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends blocksDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, blocksDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blocks
     * const blocks = await prisma.blocks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends blocksUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, blocksUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Blocks.
     * @param {blocksUpsertArgs} args - Arguments to update or create a Blocks.
     * @example
     * // Update or create a Blocks
     * const blocks = await prisma.blocks.upsert({
     *   create: {
     *     // ... data to create a Blocks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blocks we want to update
     *   }
     * })
    **/
    upsert<T extends blocksUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, blocksUpsertArgs<ExtArgs>>
    ): Prisma__blocksClient<$Result.GetResult<Prisma.$blocksPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksCountArgs} args - Arguments to filter Blocks to count.
     * @example
     * // Count the number of Blocks
     * const count = await prisma.blocks.count({
     *   where: {
     *     // ... the filter for the Blocks we want to count
     *   }
     * })
    **/
    count<T extends blocksCountArgs>(
      args?: Subset<T, blocksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlocksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlocksAggregateArgs>(args: Subset<T, BlocksAggregateArgs>): Prisma.PrismaPromise<GetBlocksAggregateType<T>>

    /**
     * Group by Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends blocksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: blocksGroupByArgs['orderBy'] }
        : { orderBy?: blocksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, blocksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlocksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the blocks model
   */
  readonly fields: blocksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for blocks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__blocksClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the blocks model
   */ 
  interface blocksFieldRefs {
    readonly number: FieldRef<"blocks", 'BigInt'>
    readonly hash: FieldRef<"blocks", 'String'>
    readonly parent_hash: FieldRef<"blocks", 'String'>
    readonly nonce: FieldRef<"blocks", 'String'>
    readonly logs_bloom: FieldRef<"blocks", 'String'>
    readonly transactions_root: FieldRef<"blocks", 'String'>
    readonly state_root: FieldRef<"blocks", 'String'>
    readonly receipts_root: FieldRef<"blocks", 'String'>
    readonly fee_recipient: FieldRef<"blocks", 'String'>
    readonly proposer_index: FieldRef<"blocks", 'BigInt'>
    readonly gas_limit: FieldRef<"blocks", 'BigInt'>
    readonly gas_used: FieldRef<"blocks", 'BigInt'>
    readonly timestamp: FieldRef<"blocks", 'DateTime'>
    readonly transaction_count: FieldRef<"blocks", 'BigInt'>
  }
    

  // Custom InputTypes

  /**
   * blocks findUnique
   */
  export type blocksFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where: blocksWhereUniqueInput
  }


  /**
   * blocks findUniqueOrThrow
   */
  export type blocksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where: blocksWhereUniqueInput
  }


  /**
   * blocks findFirst
   */
  export type blocksFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blocks.
     */
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blocks.
     */
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }


  /**
   * blocks findFirstOrThrow
   */
  export type blocksFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blocks.
     */
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blocks.
     */
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }


  /**
   * blocks findMany
   */
  export type blocksFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blocksOrderByWithRelationInput | blocksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blocks.
     */
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    distinct?: BlocksScalarFieldEnum | BlocksScalarFieldEnum[]
  }


  /**
   * blocks create
   */
  export type blocksCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * The data needed to create a blocks.
     */
    data: XOR<blocksCreateInput, blocksUncheckedCreateInput>
  }


  /**
   * blocks createMany
   */
  export type blocksCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many blocks.
     */
    data: blocksCreateManyInput | blocksCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * blocks update
   */
  export type blocksUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * The data needed to update a blocks.
     */
    data: XOR<blocksUpdateInput, blocksUncheckedUpdateInput>
    /**
     * Choose, which blocks to update.
     */
    where: blocksWhereUniqueInput
  }


  /**
   * blocks updateMany
   */
  export type blocksUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update blocks.
     */
    data: XOR<blocksUpdateManyMutationInput, blocksUncheckedUpdateManyInput>
    /**
     * Filter which blocks to update
     */
    where?: blocksWhereInput
  }


  /**
   * blocks upsert
   */
  export type blocksUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * The filter to search for the blocks to update in case it exists.
     */
    where: blocksWhereUniqueInput
    /**
     * In case the blocks found by the `where` argument doesn't exist, create a new blocks with this data.
     */
    create: XOR<blocksCreateInput, blocksUncheckedCreateInput>
    /**
     * In case the blocks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blocksUpdateInput, blocksUncheckedUpdateInput>
  }


  /**
   * blocks delete
   */
  export type blocksDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
    /**
     * Filter which blocks to delete.
     */
    where: blocksWhereUniqueInput
  }


  /**
   * blocks deleteMany
   */
  export type blocksDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which blocks to delete
     */
    where?: blocksWhereInput
  }


  /**
   * blocks without action
   */
  export type blocksDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blocks
     */
    select?: blocksSelect<ExtArgs> | null
  }



  /**
   * Model d_account
   */

  export type AggregateD_account = {
    _count: D_accountCountAggregateOutputType | null
    _avg: D_accountAvgAggregateOutputType | null
    _sum: D_accountSumAggregateOutputType | null
    _min: D_accountMinAggregateOutputType | null
    _max: D_accountMaxAggregateOutputType | null
  }

  export type D_accountAvgAggregateOutputType = {
    account_id: number | null
    eth_sent: number | null
    eth_received: number | null
    account_balance: number | null
  }

  export type D_accountSumAggregateOutputType = {
    account_id: bigint | null
    eth_sent: number | null
    eth_received: number | null
    account_balance: number | null
  }

  export type D_accountMinAggregateOutputType = {
    account_id: bigint | null
    address: string | null
    eth_sent: number | null
    eth_received: number | null
    account_balance: number | null
  }

  export type D_accountMaxAggregateOutputType = {
    account_id: bigint | null
    address: string | null
    eth_sent: number | null
    eth_received: number | null
    account_balance: number | null
  }

  export type D_accountCountAggregateOutputType = {
    account_id: number
    address: number
    eth_sent: number
    eth_received: number
    account_balance: number
    _all: number
  }


  export type D_accountAvgAggregateInputType = {
    account_id?: true
    eth_sent?: true
    eth_received?: true
    account_balance?: true
  }

  export type D_accountSumAggregateInputType = {
    account_id?: true
    eth_sent?: true
    eth_received?: true
    account_balance?: true
  }

  export type D_accountMinAggregateInputType = {
    account_id?: true
    address?: true
    eth_sent?: true
    eth_received?: true
    account_balance?: true
  }

  export type D_accountMaxAggregateInputType = {
    account_id?: true
    address?: true
    eth_sent?: true
    eth_received?: true
    account_balance?: true
  }

  export type D_accountCountAggregateInputType = {
    account_id?: true
    address?: true
    eth_sent?: true
    eth_received?: true
    account_balance?: true
    _all?: true
  }

  export type D_accountAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which d_account to aggregate.
     */
    where?: d_accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of d_accounts to fetch.
     */
    orderBy?: d_accountOrderByWithRelationInput | d_accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: d_accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` d_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` d_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned d_accounts
    **/
    _count?: true | D_accountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: D_accountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: D_accountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: D_accountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: D_accountMaxAggregateInputType
  }

  export type GetD_accountAggregateType<T extends D_accountAggregateArgs> = {
        [P in keyof T & keyof AggregateD_account]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateD_account[P]>
      : GetScalarType<T[P], AggregateD_account[P]>
  }




  export type d_accountGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: d_accountWhereInput
    orderBy?: d_accountOrderByWithAggregationInput | d_accountOrderByWithAggregationInput[]
    by: D_accountScalarFieldEnum[] | D_accountScalarFieldEnum
    having?: d_accountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: D_accountCountAggregateInputType | true
    _avg?: D_accountAvgAggregateInputType
    _sum?: D_accountSumAggregateInputType
    _min?: D_accountMinAggregateInputType
    _max?: D_accountMaxAggregateInputType
  }

  export type D_accountGroupByOutputType = {
    account_id: bigint
    address: string
    eth_sent: number | null
    eth_received: number | null
    account_balance: number | null
    _count: D_accountCountAggregateOutputType | null
    _avg: D_accountAvgAggregateOutputType | null
    _sum: D_accountSumAggregateOutputType | null
    _min: D_accountMinAggregateOutputType | null
    _max: D_accountMaxAggregateOutputType | null
  }

  type GetD_accountGroupByPayload<T extends d_accountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<D_accountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof D_accountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], D_accountGroupByOutputType[P]>
            : GetScalarType<T[P], D_accountGroupByOutputType[P]>
        }
      >
    >


  export type d_accountSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    account_id?: boolean
    address?: boolean
    eth_sent?: boolean
    eth_received?: boolean
    account_balance?: boolean
  }, ExtArgs["result"]["d_account"]>

  export type d_accountSelectScalar = {
    account_id?: boolean
    address?: boolean
    eth_sent?: boolean
    eth_received?: boolean
    account_balance?: boolean
  }


  export type $d_accountPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "d_account"
    objects: {}
    scalars: $Extensions.GetResult<{
      account_id: bigint
      address: string
      eth_sent: number | null
      eth_received: number | null
      account_balance: number | null
    }, ExtArgs["result"]["d_account"]>
    composites: {}
  }


  type d_accountGetPayload<S extends boolean | null | undefined | d_accountDefaultArgs> = $Result.GetResult<Prisma.$d_accountPayload, S>

  type d_accountCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<d_accountFindManyArgs, 'select' | 'include'> & {
      select?: D_accountCountAggregateInputType | true
    }

  export interface d_accountDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['d_account'], meta: { name: 'd_account' } }
    /**
     * Find zero or one D_account that matches the filter.
     * @param {d_accountFindUniqueArgs} args - Arguments to find a D_account
     * @example
     * // Get one D_account
     * const d_account = await prisma.d_account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends d_accountFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, d_accountFindUniqueArgs<ExtArgs>>
    ): Prisma__d_accountClient<$Result.GetResult<Prisma.$d_accountPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one D_account that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {d_accountFindUniqueOrThrowArgs} args - Arguments to find a D_account
     * @example
     * // Get one D_account
     * const d_account = await prisma.d_account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends d_accountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, d_accountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__d_accountClient<$Result.GetResult<Prisma.$d_accountPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first D_account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_accountFindFirstArgs} args - Arguments to find a D_account
     * @example
     * // Get one D_account
     * const d_account = await prisma.d_account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends d_accountFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, d_accountFindFirstArgs<ExtArgs>>
    ): Prisma__d_accountClient<$Result.GetResult<Prisma.$d_accountPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first D_account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_accountFindFirstOrThrowArgs} args - Arguments to find a D_account
     * @example
     * // Get one D_account
     * const d_account = await prisma.d_account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends d_accountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, d_accountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__d_accountClient<$Result.GetResult<Prisma.$d_accountPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more D_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_accountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all D_accounts
     * const d_accounts = await prisma.d_account.findMany()
     * 
     * // Get first 10 D_accounts
     * const d_accounts = await prisma.d_account.findMany({ take: 10 })
     * 
     * // Only select the `account_id`
     * const d_accountWithAccount_idOnly = await prisma.d_account.findMany({ select: { account_id: true } })
     * 
    **/
    findMany<T extends d_accountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, d_accountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$d_accountPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a D_account.
     * @param {d_accountCreateArgs} args - Arguments to create a D_account.
     * @example
     * // Create one D_account
     * const D_account = await prisma.d_account.create({
     *   data: {
     *     // ... data to create a D_account
     *   }
     * })
     * 
    **/
    create<T extends d_accountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, d_accountCreateArgs<ExtArgs>>
    ): Prisma__d_accountClient<$Result.GetResult<Prisma.$d_accountPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many D_accounts.
     *     @param {d_accountCreateManyArgs} args - Arguments to create many D_accounts.
     *     @example
     *     // Create many D_accounts
     *     const d_account = await prisma.d_account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends d_accountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, d_accountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a D_account.
     * @param {d_accountDeleteArgs} args - Arguments to delete one D_account.
     * @example
     * // Delete one D_account
     * const D_account = await prisma.d_account.delete({
     *   where: {
     *     // ... filter to delete one D_account
     *   }
     * })
     * 
    **/
    delete<T extends d_accountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, d_accountDeleteArgs<ExtArgs>>
    ): Prisma__d_accountClient<$Result.GetResult<Prisma.$d_accountPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one D_account.
     * @param {d_accountUpdateArgs} args - Arguments to update one D_account.
     * @example
     * // Update one D_account
     * const d_account = await prisma.d_account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends d_accountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, d_accountUpdateArgs<ExtArgs>>
    ): Prisma__d_accountClient<$Result.GetResult<Prisma.$d_accountPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more D_accounts.
     * @param {d_accountDeleteManyArgs} args - Arguments to filter D_accounts to delete.
     * @example
     * // Delete a few D_accounts
     * const { count } = await prisma.d_account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends d_accountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, d_accountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more D_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_accountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many D_accounts
     * const d_account = await prisma.d_account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends d_accountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, d_accountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one D_account.
     * @param {d_accountUpsertArgs} args - Arguments to update or create a D_account.
     * @example
     * // Update or create a D_account
     * const d_account = await prisma.d_account.upsert({
     *   create: {
     *     // ... data to create a D_account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the D_account we want to update
     *   }
     * })
    **/
    upsert<T extends d_accountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, d_accountUpsertArgs<ExtArgs>>
    ): Prisma__d_accountClient<$Result.GetResult<Prisma.$d_accountPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of D_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_accountCountArgs} args - Arguments to filter D_accounts to count.
     * @example
     * // Count the number of D_accounts
     * const count = await prisma.d_account.count({
     *   where: {
     *     // ... the filter for the D_accounts we want to count
     *   }
     * })
    **/
    count<T extends d_accountCountArgs>(
      args?: Subset<T, d_accountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], D_accountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a D_account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {D_accountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends D_accountAggregateArgs>(args: Subset<T, D_accountAggregateArgs>): Prisma.PrismaPromise<GetD_accountAggregateType<T>>

    /**
     * Group by D_account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_accountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends d_accountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: d_accountGroupByArgs['orderBy'] }
        : { orderBy?: d_accountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, d_accountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetD_accountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the d_account model
   */
  readonly fields: d_accountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for d_account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__d_accountClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the d_account model
   */ 
  interface d_accountFieldRefs {
    readonly account_id: FieldRef<"d_account", 'BigInt'>
    readonly address: FieldRef<"d_account", 'String'>
    readonly eth_sent: FieldRef<"d_account", 'Float'>
    readonly eth_received: FieldRef<"d_account", 'Float'>
    readonly account_balance: FieldRef<"d_account", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * d_account findUnique
   */
  export type d_accountFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_account
     */
    select?: d_accountSelect<ExtArgs> | null
    /**
     * Filter, which d_account to fetch.
     */
    where: d_accountWhereUniqueInput
  }


  /**
   * d_account findUniqueOrThrow
   */
  export type d_accountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_account
     */
    select?: d_accountSelect<ExtArgs> | null
    /**
     * Filter, which d_account to fetch.
     */
    where: d_accountWhereUniqueInput
  }


  /**
   * d_account findFirst
   */
  export type d_accountFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_account
     */
    select?: d_accountSelect<ExtArgs> | null
    /**
     * Filter, which d_account to fetch.
     */
    where?: d_accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of d_accounts to fetch.
     */
    orderBy?: d_accountOrderByWithRelationInput | d_accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for d_accounts.
     */
    cursor?: d_accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` d_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` d_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of d_accounts.
     */
    distinct?: D_accountScalarFieldEnum | D_accountScalarFieldEnum[]
  }


  /**
   * d_account findFirstOrThrow
   */
  export type d_accountFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_account
     */
    select?: d_accountSelect<ExtArgs> | null
    /**
     * Filter, which d_account to fetch.
     */
    where?: d_accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of d_accounts to fetch.
     */
    orderBy?: d_accountOrderByWithRelationInput | d_accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for d_accounts.
     */
    cursor?: d_accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` d_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` d_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of d_accounts.
     */
    distinct?: D_accountScalarFieldEnum | D_accountScalarFieldEnum[]
  }


  /**
   * d_account findMany
   */
  export type d_accountFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_account
     */
    select?: d_accountSelect<ExtArgs> | null
    /**
     * Filter, which d_accounts to fetch.
     */
    where?: d_accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of d_accounts to fetch.
     */
    orderBy?: d_accountOrderByWithRelationInput | d_accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing d_accounts.
     */
    cursor?: d_accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` d_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` d_accounts.
     */
    skip?: number
    distinct?: D_accountScalarFieldEnum | D_accountScalarFieldEnum[]
  }


  /**
   * d_account create
   */
  export type d_accountCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_account
     */
    select?: d_accountSelect<ExtArgs> | null
    /**
     * The data needed to create a d_account.
     */
    data: XOR<d_accountCreateInput, d_accountUncheckedCreateInput>
  }


  /**
   * d_account createMany
   */
  export type d_accountCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many d_accounts.
     */
    data: d_accountCreateManyInput | d_accountCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * d_account update
   */
  export type d_accountUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_account
     */
    select?: d_accountSelect<ExtArgs> | null
    /**
     * The data needed to update a d_account.
     */
    data: XOR<d_accountUpdateInput, d_accountUncheckedUpdateInput>
    /**
     * Choose, which d_account to update.
     */
    where: d_accountWhereUniqueInput
  }


  /**
   * d_account updateMany
   */
  export type d_accountUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update d_accounts.
     */
    data: XOR<d_accountUpdateManyMutationInput, d_accountUncheckedUpdateManyInput>
    /**
     * Filter which d_accounts to update
     */
    where?: d_accountWhereInput
  }


  /**
   * d_account upsert
   */
  export type d_accountUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_account
     */
    select?: d_accountSelect<ExtArgs> | null
    /**
     * The filter to search for the d_account to update in case it exists.
     */
    where: d_accountWhereUniqueInput
    /**
     * In case the d_account found by the `where` argument doesn't exist, create a new d_account with this data.
     */
    create: XOR<d_accountCreateInput, d_accountUncheckedCreateInput>
    /**
     * In case the d_account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<d_accountUpdateInput, d_accountUncheckedUpdateInput>
  }


  /**
   * d_account delete
   */
  export type d_accountDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_account
     */
    select?: d_accountSelect<ExtArgs> | null
    /**
     * Filter which d_account to delete.
     */
    where: d_accountWhereUniqueInput
  }


  /**
   * d_account deleteMany
   */
  export type d_accountDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which d_accounts to delete
     */
    where?: d_accountWhereInput
  }


  /**
   * d_account without action
   */
  export type d_accountDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_account
     */
    select?: d_accountSelect<ExtArgs> | null
  }



  /**
   * Model d_block
   */

  export type AggregateD_block = {
    _count: D_blockCountAggregateOutputType | null
    _avg: D_blockAvgAggregateOutputType | null
    _sum: D_blockSumAggregateOutputType | null
    _min: D_blockMinAggregateOutputType | null
    _max: D_blockMaxAggregateOutputType | null
  }

  export type D_blockAvgAggregateOutputType = {
    block_id: number | null
    number: number | null
    proposer_index: number | null
    gas_limit: number | null
    gas_used: number | null
    transaction_count: number | null
  }

  export type D_blockSumAggregateOutputType = {
    block_id: bigint | null
    number: bigint | null
    proposer_index: bigint | null
    gas_limit: bigint | null
    gas_used: bigint | null
    transaction_count: bigint | null
  }

  export type D_blockMinAggregateOutputType = {
    block_id: bigint | null
    timestamp: Date | null
    number: bigint | null
    hash: string | null
    parent_hash: string | null
    fee_recipient: string | null
    logs_bloom: string | null
    transactions_root: string | null
    state_root: string | null
    proposer_index: bigint | null
    gas_limit: bigint | null
    gas_used: bigint | null
    transaction_count: bigint | null
  }

  export type D_blockMaxAggregateOutputType = {
    block_id: bigint | null
    timestamp: Date | null
    number: bigint | null
    hash: string | null
    parent_hash: string | null
    fee_recipient: string | null
    logs_bloom: string | null
    transactions_root: string | null
    state_root: string | null
    proposer_index: bigint | null
    gas_limit: bigint | null
    gas_used: bigint | null
    transaction_count: bigint | null
  }

  export type D_blockCountAggregateOutputType = {
    block_id: number
    timestamp: number
    number: number
    hash: number
    parent_hash: number
    fee_recipient: number
    logs_bloom: number
    transactions_root: number
    state_root: number
    proposer_index: number
    gas_limit: number
    gas_used: number
    transaction_count: number
    _all: number
  }


  export type D_blockAvgAggregateInputType = {
    block_id?: true
    number?: true
    proposer_index?: true
    gas_limit?: true
    gas_used?: true
    transaction_count?: true
  }

  export type D_blockSumAggregateInputType = {
    block_id?: true
    number?: true
    proposer_index?: true
    gas_limit?: true
    gas_used?: true
    transaction_count?: true
  }

  export type D_blockMinAggregateInputType = {
    block_id?: true
    timestamp?: true
    number?: true
    hash?: true
    parent_hash?: true
    fee_recipient?: true
    logs_bloom?: true
    transactions_root?: true
    state_root?: true
    proposer_index?: true
    gas_limit?: true
    gas_used?: true
    transaction_count?: true
  }

  export type D_blockMaxAggregateInputType = {
    block_id?: true
    timestamp?: true
    number?: true
    hash?: true
    parent_hash?: true
    fee_recipient?: true
    logs_bloom?: true
    transactions_root?: true
    state_root?: true
    proposer_index?: true
    gas_limit?: true
    gas_used?: true
    transaction_count?: true
  }

  export type D_blockCountAggregateInputType = {
    block_id?: true
    timestamp?: true
    number?: true
    hash?: true
    parent_hash?: true
    fee_recipient?: true
    logs_bloom?: true
    transactions_root?: true
    state_root?: true
    proposer_index?: true
    gas_limit?: true
    gas_used?: true
    transaction_count?: true
    _all?: true
  }

  export type D_blockAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which d_block to aggregate.
     */
    where?: d_blockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of d_blocks to fetch.
     */
    orderBy?: d_blockOrderByWithRelationInput | d_blockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: d_blockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` d_blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` d_blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned d_blocks
    **/
    _count?: true | D_blockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: D_blockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: D_blockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: D_blockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: D_blockMaxAggregateInputType
  }

  export type GetD_blockAggregateType<T extends D_blockAggregateArgs> = {
        [P in keyof T & keyof AggregateD_block]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateD_block[P]>
      : GetScalarType<T[P], AggregateD_block[P]>
  }




  export type d_blockGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: d_blockWhereInput
    orderBy?: d_blockOrderByWithAggregationInput | d_blockOrderByWithAggregationInput[]
    by: D_blockScalarFieldEnum[] | D_blockScalarFieldEnum
    having?: d_blockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: D_blockCountAggregateInputType | true
    _avg?: D_blockAvgAggregateInputType
    _sum?: D_blockSumAggregateInputType
    _min?: D_blockMinAggregateInputType
    _max?: D_blockMaxAggregateInputType
  }

  export type D_blockGroupByOutputType = {
    block_id: bigint
    timestamp: Date | null
    number: bigint | null
    hash: string | null
    parent_hash: string | null
    fee_recipient: string | null
    logs_bloom: string | null
    transactions_root: string | null
    state_root: string | null
    proposer_index: bigint | null
    gas_limit: bigint | null
    gas_used: bigint | null
    transaction_count: bigint | null
    _count: D_blockCountAggregateOutputType | null
    _avg: D_blockAvgAggregateOutputType | null
    _sum: D_blockSumAggregateOutputType | null
    _min: D_blockMinAggregateOutputType | null
    _max: D_blockMaxAggregateOutputType | null
  }

  type GetD_blockGroupByPayload<T extends d_blockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<D_blockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof D_blockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], D_blockGroupByOutputType[P]>
            : GetScalarType<T[P], D_blockGroupByOutputType[P]>
        }
      >
    >


  export type d_blockSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    block_id?: boolean
    timestamp?: boolean
    number?: boolean
    hash?: boolean
    parent_hash?: boolean
    fee_recipient?: boolean
    logs_bloom?: boolean
    transactions_root?: boolean
    state_root?: boolean
    proposer_index?: boolean
    gas_limit?: boolean
    gas_used?: boolean
    transaction_count?: boolean
  }, ExtArgs["result"]["d_block"]>

  export type d_blockSelectScalar = {
    block_id?: boolean
    timestamp?: boolean
    number?: boolean
    hash?: boolean
    parent_hash?: boolean
    fee_recipient?: boolean
    logs_bloom?: boolean
    transactions_root?: boolean
    state_root?: boolean
    proposer_index?: boolean
    gas_limit?: boolean
    gas_used?: boolean
    transaction_count?: boolean
  }


  export type $d_blockPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "d_block"
    objects: {}
    scalars: $Extensions.GetResult<{
      block_id: bigint
      timestamp: Date | null
      number: bigint | null
      hash: string | null
      parent_hash: string | null
      fee_recipient: string | null
      logs_bloom: string | null
      transactions_root: string | null
      state_root: string | null
      proposer_index: bigint | null
      gas_limit: bigint | null
      gas_used: bigint | null
      transaction_count: bigint | null
    }, ExtArgs["result"]["d_block"]>
    composites: {}
  }


  type d_blockGetPayload<S extends boolean | null | undefined | d_blockDefaultArgs> = $Result.GetResult<Prisma.$d_blockPayload, S>

  type d_blockCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<d_blockFindManyArgs, 'select' | 'include'> & {
      select?: D_blockCountAggregateInputType | true
    }

  export interface d_blockDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['d_block'], meta: { name: 'd_block' } }
    /**
     * Find zero or one D_block that matches the filter.
     * @param {d_blockFindUniqueArgs} args - Arguments to find a D_block
     * @example
     * // Get one D_block
     * const d_block = await prisma.d_block.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends d_blockFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, d_blockFindUniqueArgs<ExtArgs>>
    ): Prisma__d_blockClient<$Result.GetResult<Prisma.$d_blockPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one D_block that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {d_blockFindUniqueOrThrowArgs} args - Arguments to find a D_block
     * @example
     * // Get one D_block
     * const d_block = await prisma.d_block.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends d_blockFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, d_blockFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__d_blockClient<$Result.GetResult<Prisma.$d_blockPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first D_block that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_blockFindFirstArgs} args - Arguments to find a D_block
     * @example
     * // Get one D_block
     * const d_block = await prisma.d_block.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends d_blockFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, d_blockFindFirstArgs<ExtArgs>>
    ): Prisma__d_blockClient<$Result.GetResult<Prisma.$d_blockPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first D_block that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_blockFindFirstOrThrowArgs} args - Arguments to find a D_block
     * @example
     * // Get one D_block
     * const d_block = await prisma.d_block.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends d_blockFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, d_blockFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__d_blockClient<$Result.GetResult<Prisma.$d_blockPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more D_blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_blockFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all D_blocks
     * const d_blocks = await prisma.d_block.findMany()
     * 
     * // Get first 10 D_blocks
     * const d_blocks = await prisma.d_block.findMany({ take: 10 })
     * 
     * // Only select the `block_id`
     * const d_blockWithBlock_idOnly = await prisma.d_block.findMany({ select: { block_id: true } })
     * 
    **/
    findMany<T extends d_blockFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, d_blockFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$d_blockPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a D_block.
     * @param {d_blockCreateArgs} args - Arguments to create a D_block.
     * @example
     * // Create one D_block
     * const D_block = await prisma.d_block.create({
     *   data: {
     *     // ... data to create a D_block
     *   }
     * })
     * 
    **/
    create<T extends d_blockCreateArgs<ExtArgs>>(
      args: SelectSubset<T, d_blockCreateArgs<ExtArgs>>
    ): Prisma__d_blockClient<$Result.GetResult<Prisma.$d_blockPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many D_blocks.
     *     @param {d_blockCreateManyArgs} args - Arguments to create many D_blocks.
     *     @example
     *     // Create many D_blocks
     *     const d_block = await prisma.d_block.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends d_blockCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, d_blockCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a D_block.
     * @param {d_blockDeleteArgs} args - Arguments to delete one D_block.
     * @example
     * // Delete one D_block
     * const D_block = await prisma.d_block.delete({
     *   where: {
     *     // ... filter to delete one D_block
     *   }
     * })
     * 
    **/
    delete<T extends d_blockDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, d_blockDeleteArgs<ExtArgs>>
    ): Prisma__d_blockClient<$Result.GetResult<Prisma.$d_blockPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one D_block.
     * @param {d_blockUpdateArgs} args - Arguments to update one D_block.
     * @example
     * // Update one D_block
     * const d_block = await prisma.d_block.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends d_blockUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, d_blockUpdateArgs<ExtArgs>>
    ): Prisma__d_blockClient<$Result.GetResult<Prisma.$d_blockPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more D_blocks.
     * @param {d_blockDeleteManyArgs} args - Arguments to filter D_blocks to delete.
     * @example
     * // Delete a few D_blocks
     * const { count } = await prisma.d_block.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends d_blockDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, d_blockDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more D_blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_blockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many D_blocks
     * const d_block = await prisma.d_block.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends d_blockUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, d_blockUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one D_block.
     * @param {d_blockUpsertArgs} args - Arguments to update or create a D_block.
     * @example
     * // Update or create a D_block
     * const d_block = await prisma.d_block.upsert({
     *   create: {
     *     // ... data to create a D_block
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the D_block we want to update
     *   }
     * })
    **/
    upsert<T extends d_blockUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, d_blockUpsertArgs<ExtArgs>>
    ): Prisma__d_blockClient<$Result.GetResult<Prisma.$d_blockPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of D_blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_blockCountArgs} args - Arguments to filter D_blocks to count.
     * @example
     * // Count the number of D_blocks
     * const count = await prisma.d_block.count({
     *   where: {
     *     // ... the filter for the D_blocks we want to count
     *   }
     * })
    **/
    count<T extends d_blockCountArgs>(
      args?: Subset<T, d_blockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], D_blockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a D_block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {D_blockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends D_blockAggregateArgs>(args: Subset<T, D_blockAggregateArgs>): Prisma.PrismaPromise<GetD_blockAggregateType<T>>

    /**
     * Group by D_block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_blockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends d_blockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: d_blockGroupByArgs['orderBy'] }
        : { orderBy?: d_blockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, d_blockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetD_blockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the d_block model
   */
  readonly fields: d_blockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for d_block.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__d_blockClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the d_block model
   */ 
  interface d_blockFieldRefs {
    readonly block_id: FieldRef<"d_block", 'BigInt'>
    readonly timestamp: FieldRef<"d_block", 'DateTime'>
    readonly number: FieldRef<"d_block", 'BigInt'>
    readonly hash: FieldRef<"d_block", 'String'>
    readonly parent_hash: FieldRef<"d_block", 'String'>
    readonly fee_recipient: FieldRef<"d_block", 'String'>
    readonly logs_bloom: FieldRef<"d_block", 'String'>
    readonly transactions_root: FieldRef<"d_block", 'String'>
    readonly state_root: FieldRef<"d_block", 'String'>
    readonly proposer_index: FieldRef<"d_block", 'BigInt'>
    readonly gas_limit: FieldRef<"d_block", 'BigInt'>
    readonly gas_used: FieldRef<"d_block", 'BigInt'>
    readonly transaction_count: FieldRef<"d_block", 'BigInt'>
  }
    

  // Custom InputTypes

  /**
   * d_block findUnique
   */
  export type d_blockFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_block
     */
    select?: d_blockSelect<ExtArgs> | null
    /**
     * Filter, which d_block to fetch.
     */
    where: d_blockWhereUniqueInput
  }


  /**
   * d_block findUniqueOrThrow
   */
  export type d_blockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_block
     */
    select?: d_blockSelect<ExtArgs> | null
    /**
     * Filter, which d_block to fetch.
     */
    where: d_blockWhereUniqueInput
  }


  /**
   * d_block findFirst
   */
  export type d_blockFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_block
     */
    select?: d_blockSelect<ExtArgs> | null
    /**
     * Filter, which d_block to fetch.
     */
    where?: d_blockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of d_blocks to fetch.
     */
    orderBy?: d_blockOrderByWithRelationInput | d_blockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for d_blocks.
     */
    cursor?: d_blockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` d_blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` d_blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of d_blocks.
     */
    distinct?: D_blockScalarFieldEnum | D_blockScalarFieldEnum[]
  }


  /**
   * d_block findFirstOrThrow
   */
  export type d_blockFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_block
     */
    select?: d_blockSelect<ExtArgs> | null
    /**
     * Filter, which d_block to fetch.
     */
    where?: d_blockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of d_blocks to fetch.
     */
    orderBy?: d_blockOrderByWithRelationInput | d_blockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for d_blocks.
     */
    cursor?: d_blockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` d_blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` d_blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of d_blocks.
     */
    distinct?: D_blockScalarFieldEnum | D_blockScalarFieldEnum[]
  }


  /**
   * d_block findMany
   */
  export type d_blockFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_block
     */
    select?: d_blockSelect<ExtArgs> | null
    /**
     * Filter, which d_blocks to fetch.
     */
    where?: d_blockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of d_blocks to fetch.
     */
    orderBy?: d_blockOrderByWithRelationInput | d_blockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing d_blocks.
     */
    cursor?: d_blockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` d_blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` d_blocks.
     */
    skip?: number
    distinct?: D_blockScalarFieldEnum | D_blockScalarFieldEnum[]
  }


  /**
   * d_block create
   */
  export type d_blockCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_block
     */
    select?: d_blockSelect<ExtArgs> | null
    /**
     * The data needed to create a d_block.
     */
    data?: XOR<d_blockCreateInput, d_blockUncheckedCreateInput>
  }


  /**
   * d_block createMany
   */
  export type d_blockCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many d_blocks.
     */
    data: d_blockCreateManyInput | d_blockCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * d_block update
   */
  export type d_blockUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_block
     */
    select?: d_blockSelect<ExtArgs> | null
    /**
     * The data needed to update a d_block.
     */
    data: XOR<d_blockUpdateInput, d_blockUncheckedUpdateInput>
    /**
     * Choose, which d_block to update.
     */
    where: d_blockWhereUniqueInput
  }


  /**
   * d_block updateMany
   */
  export type d_blockUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update d_blocks.
     */
    data: XOR<d_blockUpdateManyMutationInput, d_blockUncheckedUpdateManyInput>
    /**
     * Filter which d_blocks to update
     */
    where?: d_blockWhereInput
  }


  /**
   * d_block upsert
   */
  export type d_blockUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_block
     */
    select?: d_blockSelect<ExtArgs> | null
    /**
     * The filter to search for the d_block to update in case it exists.
     */
    where: d_blockWhereUniqueInput
    /**
     * In case the d_block found by the `where` argument doesn't exist, create a new d_block with this data.
     */
    create: XOR<d_blockCreateInput, d_blockUncheckedCreateInput>
    /**
     * In case the d_block was found with the provided `where` argument, update it with this data.
     */
    update: XOR<d_blockUpdateInput, d_blockUncheckedUpdateInput>
  }


  /**
   * d_block delete
   */
  export type d_blockDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_block
     */
    select?: d_blockSelect<ExtArgs> | null
    /**
     * Filter which d_block to delete.
     */
    where: d_blockWhereUniqueInput
  }


  /**
   * d_block deleteMany
   */
  export type d_blockDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which d_blocks to delete
     */
    where?: d_blockWhereInput
  }


  /**
   * d_block without action
   */
  export type d_blockDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_block
     */
    select?: d_blockSelect<ExtArgs> | null
  }



  /**
   * Model d_date
   */

  export type AggregateD_date = {
    _count: D_dateCountAggregateOutputType | null
    _avg: D_dateAvgAggregateOutputType | null
    _sum: D_dateSumAggregateOutputType | null
    _min: D_dateMinAggregateOutputType | null
    _max: D_dateMaxAggregateOutputType | null
  }

  export type D_dateAvgAggregateOutputType = {
    year: number | null
    month: number | null
    day: number | null
    weekday: number | null
    week: number | null
  }

  export type D_dateSumAggregateOutputType = {
    year: number | null
    month: number | null
    day: number | null
    weekday: number | null
    week: number | null
  }

  export type D_dateMinAggregateOutputType = {
    date: Date | null
    year: number | null
    month: number | null
    day: number | null
    weekday: number | null
    day_in_chars: string | null
    week: number | null
  }

  export type D_dateMaxAggregateOutputType = {
    date: Date | null
    year: number | null
    month: number | null
    day: number | null
    weekday: number | null
    day_in_chars: string | null
    week: number | null
  }

  export type D_dateCountAggregateOutputType = {
    date: number
    year: number
    month: number
    day: number
    weekday: number
    day_in_chars: number
    week: number
    _all: number
  }


  export type D_dateAvgAggregateInputType = {
    year?: true
    month?: true
    day?: true
    weekday?: true
    week?: true
  }

  export type D_dateSumAggregateInputType = {
    year?: true
    month?: true
    day?: true
    weekday?: true
    week?: true
  }

  export type D_dateMinAggregateInputType = {
    date?: true
    year?: true
    month?: true
    day?: true
    weekday?: true
    day_in_chars?: true
    week?: true
  }

  export type D_dateMaxAggregateInputType = {
    date?: true
    year?: true
    month?: true
    day?: true
    weekday?: true
    day_in_chars?: true
    week?: true
  }

  export type D_dateCountAggregateInputType = {
    date?: true
    year?: true
    month?: true
    day?: true
    weekday?: true
    day_in_chars?: true
    week?: true
    _all?: true
  }

  export type D_dateAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which d_date to aggregate.
     */
    where?: d_dateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of d_dates to fetch.
     */
    orderBy?: d_dateOrderByWithRelationInput | d_dateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: d_dateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` d_dates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` d_dates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned d_dates
    **/
    _count?: true | D_dateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: D_dateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: D_dateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: D_dateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: D_dateMaxAggregateInputType
  }

  export type GetD_dateAggregateType<T extends D_dateAggregateArgs> = {
        [P in keyof T & keyof AggregateD_date]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateD_date[P]>
      : GetScalarType<T[P], AggregateD_date[P]>
  }




  export type d_dateGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: d_dateWhereInput
    orderBy?: d_dateOrderByWithAggregationInput | d_dateOrderByWithAggregationInput[]
    by: D_dateScalarFieldEnum[] | D_dateScalarFieldEnum
    having?: d_dateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: D_dateCountAggregateInputType | true
    _avg?: D_dateAvgAggregateInputType
    _sum?: D_dateSumAggregateInputType
    _min?: D_dateMinAggregateInputType
    _max?: D_dateMaxAggregateInputType
  }

  export type D_dateGroupByOutputType = {
    date: Date
    year: number | null
    month: number | null
    day: number | null
    weekday: number | null
    day_in_chars: string | null
    week: number | null
    _count: D_dateCountAggregateOutputType | null
    _avg: D_dateAvgAggregateOutputType | null
    _sum: D_dateSumAggregateOutputType | null
    _min: D_dateMinAggregateOutputType | null
    _max: D_dateMaxAggregateOutputType | null
  }

  type GetD_dateGroupByPayload<T extends d_dateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<D_dateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof D_dateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], D_dateGroupByOutputType[P]>
            : GetScalarType<T[P], D_dateGroupByOutputType[P]>
        }
      >
    >


  export type d_dateSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    date?: boolean
    year?: boolean
    month?: boolean
    day?: boolean
    weekday?: boolean
    day_in_chars?: boolean
    week?: boolean
  }, ExtArgs["result"]["d_date"]>

  export type d_dateSelectScalar = {
    date?: boolean
    year?: boolean
    month?: boolean
    day?: boolean
    weekday?: boolean
    day_in_chars?: boolean
    week?: boolean
  }


  export type $d_datePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "d_date"
    objects: {}
    scalars: $Extensions.GetResult<{
      date: Date
      year: number | null
      month: number | null
      day: number | null
      weekday: number | null
      day_in_chars: string | null
      week: number | null
    }, ExtArgs["result"]["d_date"]>
    composites: {}
  }


  type d_dateGetPayload<S extends boolean | null | undefined | d_dateDefaultArgs> = $Result.GetResult<Prisma.$d_datePayload, S>

  type d_dateCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<d_dateFindManyArgs, 'select' | 'include'> & {
      select?: D_dateCountAggregateInputType | true
    }

  export interface d_dateDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['d_date'], meta: { name: 'd_date' } }
    /**
     * Find zero or one D_date that matches the filter.
     * @param {d_dateFindUniqueArgs} args - Arguments to find a D_date
     * @example
     * // Get one D_date
     * const d_date = await prisma.d_date.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends d_dateFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, d_dateFindUniqueArgs<ExtArgs>>
    ): Prisma__d_dateClient<$Result.GetResult<Prisma.$d_datePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one D_date that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {d_dateFindUniqueOrThrowArgs} args - Arguments to find a D_date
     * @example
     * // Get one D_date
     * const d_date = await prisma.d_date.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends d_dateFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, d_dateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__d_dateClient<$Result.GetResult<Prisma.$d_datePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first D_date that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_dateFindFirstArgs} args - Arguments to find a D_date
     * @example
     * // Get one D_date
     * const d_date = await prisma.d_date.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends d_dateFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, d_dateFindFirstArgs<ExtArgs>>
    ): Prisma__d_dateClient<$Result.GetResult<Prisma.$d_datePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first D_date that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_dateFindFirstOrThrowArgs} args - Arguments to find a D_date
     * @example
     * // Get one D_date
     * const d_date = await prisma.d_date.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends d_dateFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, d_dateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__d_dateClient<$Result.GetResult<Prisma.$d_datePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more D_dates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_dateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all D_dates
     * const d_dates = await prisma.d_date.findMany()
     * 
     * // Get first 10 D_dates
     * const d_dates = await prisma.d_date.findMany({ take: 10 })
     * 
     * // Only select the `date`
     * const d_dateWithDateOnly = await prisma.d_date.findMany({ select: { date: true } })
     * 
    **/
    findMany<T extends d_dateFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, d_dateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$d_datePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a D_date.
     * @param {d_dateCreateArgs} args - Arguments to create a D_date.
     * @example
     * // Create one D_date
     * const D_date = await prisma.d_date.create({
     *   data: {
     *     // ... data to create a D_date
     *   }
     * })
     * 
    **/
    create<T extends d_dateCreateArgs<ExtArgs>>(
      args: SelectSubset<T, d_dateCreateArgs<ExtArgs>>
    ): Prisma__d_dateClient<$Result.GetResult<Prisma.$d_datePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many D_dates.
     *     @param {d_dateCreateManyArgs} args - Arguments to create many D_dates.
     *     @example
     *     // Create many D_dates
     *     const d_date = await prisma.d_date.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends d_dateCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, d_dateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a D_date.
     * @param {d_dateDeleteArgs} args - Arguments to delete one D_date.
     * @example
     * // Delete one D_date
     * const D_date = await prisma.d_date.delete({
     *   where: {
     *     // ... filter to delete one D_date
     *   }
     * })
     * 
    **/
    delete<T extends d_dateDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, d_dateDeleteArgs<ExtArgs>>
    ): Prisma__d_dateClient<$Result.GetResult<Prisma.$d_datePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one D_date.
     * @param {d_dateUpdateArgs} args - Arguments to update one D_date.
     * @example
     * // Update one D_date
     * const d_date = await prisma.d_date.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends d_dateUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, d_dateUpdateArgs<ExtArgs>>
    ): Prisma__d_dateClient<$Result.GetResult<Prisma.$d_datePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more D_dates.
     * @param {d_dateDeleteManyArgs} args - Arguments to filter D_dates to delete.
     * @example
     * // Delete a few D_dates
     * const { count } = await prisma.d_date.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends d_dateDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, d_dateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more D_dates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_dateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many D_dates
     * const d_date = await prisma.d_date.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends d_dateUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, d_dateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one D_date.
     * @param {d_dateUpsertArgs} args - Arguments to update or create a D_date.
     * @example
     * // Update or create a D_date
     * const d_date = await prisma.d_date.upsert({
     *   create: {
     *     // ... data to create a D_date
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the D_date we want to update
     *   }
     * })
    **/
    upsert<T extends d_dateUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, d_dateUpsertArgs<ExtArgs>>
    ): Prisma__d_dateClient<$Result.GetResult<Prisma.$d_datePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of D_dates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_dateCountArgs} args - Arguments to filter D_dates to count.
     * @example
     * // Count the number of D_dates
     * const count = await prisma.d_date.count({
     *   where: {
     *     // ... the filter for the D_dates we want to count
     *   }
     * })
    **/
    count<T extends d_dateCountArgs>(
      args?: Subset<T, d_dateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], D_dateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a D_date.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {D_dateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends D_dateAggregateArgs>(args: Subset<T, D_dateAggregateArgs>): Prisma.PrismaPromise<GetD_dateAggregateType<T>>

    /**
     * Group by D_date.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_dateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends d_dateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: d_dateGroupByArgs['orderBy'] }
        : { orderBy?: d_dateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, d_dateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetD_dateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the d_date model
   */
  readonly fields: d_dateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for d_date.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__d_dateClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the d_date model
   */ 
  interface d_dateFieldRefs {
    readonly date: FieldRef<"d_date", 'DateTime'>
    readonly year: FieldRef<"d_date", 'Int'>
    readonly month: FieldRef<"d_date", 'Int'>
    readonly day: FieldRef<"d_date", 'Int'>
    readonly weekday: FieldRef<"d_date", 'Int'>
    readonly day_in_chars: FieldRef<"d_date", 'String'>
    readonly week: FieldRef<"d_date", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * d_date findUnique
   */
  export type d_dateFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_date
     */
    select?: d_dateSelect<ExtArgs> | null
    /**
     * Filter, which d_date to fetch.
     */
    where: d_dateWhereUniqueInput
  }


  /**
   * d_date findUniqueOrThrow
   */
  export type d_dateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_date
     */
    select?: d_dateSelect<ExtArgs> | null
    /**
     * Filter, which d_date to fetch.
     */
    where: d_dateWhereUniqueInput
  }


  /**
   * d_date findFirst
   */
  export type d_dateFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_date
     */
    select?: d_dateSelect<ExtArgs> | null
    /**
     * Filter, which d_date to fetch.
     */
    where?: d_dateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of d_dates to fetch.
     */
    orderBy?: d_dateOrderByWithRelationInput | d_dateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for d_dates.
     */
    cursor?: d_dateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` d_dates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` d_dates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of d_dates.
     */
    distinct?: D_dateScalarFieldEnum | D_dateScalarFieldEnum[]
  }


  /**
   * d_date findFirstOrThrow
   */
  export type d_dateFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_date
     */
    select?: d_dateSelect<ExtArgs> | null
    /**
     * Filter, which d_date to fetch.
     */
    where?: d_dateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of d_dates to fetch.
     */
    orderBy?: d_dateOrderByWithRelationInput | d_dateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for d_dates.
     */
    cursor?: d_dateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` d_dates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` d_dates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of d_dates.
     */
    distinct?: D_dateScalarFieldEnum | D_dateScalarFieldEnum[]
  }


  /**
   * d_date findMany
   */
  export type d_dateFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_date
     */
    select?: d_dateSelect<ExtArgs> | null
    /**
     * Filter, which d_dates to fetch.
     */
    where?: d_dateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of d_dates to fetch.
     */
    orderBy?: d_dateOrderByWithRelationInput | d_dateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing d_dates.
     */
    cursor?: d_dateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` d_dates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` d_dates.
     */
    skip?: number
    distinct?: D_dateScalarFieldEnum | D_dateScalarFieldEnum[]
  }


  /**
   * d_date create
   */
  export type d_dateCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_date
     */
    select?: d_dateSelect<ExtArgs> | null
    /**
     * The data needed to create a d_date.
     */
    data: XOR<d_dateCreateInput, d_dateUncheckedCreateInput>
  }


  /**
   * d_date createMany
   */
  export type d_dateCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many d_dates.
     */
    data: d_dateCreateManyInput | d_dateCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * d_date update
   */
  export type d_dateUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_date
     */
    select?: d_dateSelect<ExtArgs> | null
    /**
     * The data needed to update a d_date.
     */
    data: XOR<d_dateUpdateInput, d_dateUncheckedUpdateInput>
    /**
     * Choose, which d_date to update.
     */
    where: d_dateWhereUniqueInput
  }


  /**
   * d_date updateMany
   */
  export type d_dateUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update d_dates.
     */
    data: XOR<d_dateUpdateManyMutationInput, d_dateUncheckedUpdateManyInput>
    /**
     * Filter which d_dates to update
     */
    where?: d_dateWhereInput
  }


  /**
   * d_date upsert
   */
  export type d_dateUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_date
     */
    select?: d_dateSelect<ExtArgs> | null
    /**
     * The filter to search for the d_date to update in case it exists.
     */
    where: d_dateWhereUniqueInput
    /**
     * In case the d_date found by the `where` argument doesn't exist, create a new d_date with this data.
     */
    create: XOR<d_dateCreateInput, d_dateUncheckedCreateInput>
    /**
     * In case the d_date was found with the provided `where` argument, update it with this data.
     */
    update: XOR<d_dateUpdateInput, d_dateUncheckedUpdateInput>
  }


  /**
   * d_date delete
   */
  export type d_dateDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_date
     */
    select?: d_dateSelect<ExtArgs> | null
    /**
     * Filter which d_date to delete.
     */
    where: d_dateWhereUniqueInput
  }


  /**
   * d_date deleteMany
   */
  export type d_dateDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which d_dates to delete
     */
    where?: d_dateWhereInput
  }


  /**
   * d_date without action
   */
  export type d_dateDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_date
     */
    select?: d_dateSelect<ExtArgs> | null
  }



  /**
   * Model d_time
   */

  export type AggregateD_time = {
    _count: D_timeCountAggregateOutputType | null
    _avg: D_timeAvgAggregateOutputType | null
    _sum: D_timeSumAggregateOutputType | null
    _min: D_timeMinAggregateOutputType | null
    _max: D_timeMaxAggregateOutputType | null
  }

  export type D_timeAvgAggregateOutputType = {
    hours: number | null
    minutes: number | null
    seconds: number | null
  }

  export type D_timeSumAggregateOutputType = {
    hours: number | null
    minutes: number | null
    seconds: number | null
  }

  export type D_timeMinAggregateOutputType = {
    time: Date | null
    hours: number | null
    minutes: number | null
    seconds: number | null
  }

  export type D_timeMaxAggregateOutputType = {
    time: Date | null
    hours: number | null
    minutes: number | null
    seconds: number | null
  }

  export type D_timeCountAggregateOutputType = {
    time: number
    hours: number
    minutes: number
    seconds: number
    _all: number
  }


  export type D_timeAvgAggregateInputType = {
    hours?: true
    minutes?: true
    seconds?: true
  }

  export type D_timeSumAggregateInputType = {
    hours?: true
    minutes?: true
    seconds?: true
  }

  export type D_timeMinAggregateInputType = {
    time?: true
    hours?: true
    minutes?: true
    seconds?: true
  }

  export type D_timeMaxAggregateInputType = {
    time?: true
    hours?: true
    minutes?: true
    seconds?: true
  }

  export type D_timeCountAggregateInputType = {
    time?: true
    hours?: true
    minutes?: true
    seconds?: true
    _all?: true
  }

  export type D_timeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which d_time to aggregate.
     */
    where?: d_timeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of d_times to fetch.
     */
    orderBy?: d_timeOrderByWithRelationInput | d_timeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: d_timeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` d_times from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` d_times.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned d_times
    **/
    _count?: true | D_timeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: D_timeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: D_timeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: D_timeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: D_timeMaxAggregateInputType
  }

  export type GetD_timeAggregateType<T extends D_timeAggregateArgs> = {
        [P in keyof T & keyof AggregateD_time]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateD_time[P]>
      : GetScalarType<T[P], AggregateD_time[P]>
  }




  export type d_timeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: d_timeWhereInput
    orderBy?: d_timeOrderByWithAggregationInput | d_timeOrderByWithAggregationInput[]
    by: D_timeScalarFieldEnum[] | D_timeScalarFieldEnum
    having?: d_timeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: D_timeCountAggregateInputType | true
    _avg?: D_timeAvgAggregateInputType
    _sum?: D_timeSumAggregateInputType
    _min?: D_timeMinAggregateInputType
    _max?: D_timeMaxAggregateInputType
  }

  export type D_timeGroupByOutputType = {
    time: Date
    hours: number | null
    minutes: number | null
    seconds: number | null
    _count: D_timeCountAggregateOutputType | null
    _avg: D_timeAvgAggregateOutputType | null
    _sum: D_timeSumAggregateOutputType | null
    _min: D_timeMinAggregateOutputType | null
    _max: D_timeMaxAggregateOutputType | null
  }

  type GetD_timeGroupByPayload<T extends d_timeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<D_timeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof D_timeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], D_timeGroupByOutputType[P]>
            : GetScalarType<T[P], D_timeGroupByOutputType[P]>
        }
      >
    >


  export type d_timeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    time?: boolean
    hours?: boolean
    minutes?: boolean
    seconds?: boolean
  }, ExtArgs["result"]["d_time"]>

  export type d_timeSelectScalar = {
    time?: boolean
    hours?: boolean
    minutes?: boolean
    seconds?: boolean
  }


  export type $d_timePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "d_time"
    objects: {}
    scalars: $Extensions.GetResult<{
      time: Date
      hours: number | null
      minutes: number | null
      seconds: number | null
    }, ExtArgs["result"]["d_time"]>
    composites: {}
  }


  type d_timeGetPayload<S extends boolean | null | undefined | d_timeDefaultArgs> = $Result.GetResult<Prisma.$d_timePayload, S>

  type d_timeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<d_timeFindManyArgs, 'select' | 'include'> & {
      select?: D_timeCountAggregateInputType | true
    }

  export interface d_timeDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['d_time'], meta: { name: 'd_time' } }
    /**
     * Find zero or one D_time that matches the filter.
     * @param {d_timeFindUniqueArgs} args - Arguments to find a D_time
     * @example
     * // Get one D_time
     * const d_time = await prisma.d_time.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends d_timeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, d_timeFindUniqueArgs<ExtArgs>>
    ): Prisma__d_timeClient<$Result.GetResult<Prisma.$d_timePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one D_time that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {d_timeFindUniqueOrThrowArgs} args - Arguments to find a D_time
     * @example
     * // Get one D_time
     * const d_time = await prisma.d_time.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends d_timeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, d_timeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__d_timeClient<$Result.GetResult<Prisma.$d_timePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first D_time that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_timeFindFirstArgs} args - Arguments to find a D_time
     * @example
     * // Get one D_time
     * const d_time = await prisma.d_time.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends d_timeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, d_timeFindFirstArgs<ExtArgs>>
    ): Prisma__d_timeClient<$Result.GetResult<Prisma.$d_timePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first D_time that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_timeFindFirstOrThrowArgs} args - Arguments to find a D_time
     * @example
     * // Get one D_time
     * const d_time = await prisma.d_time.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends d_timeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, d_timeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__d_timeClient<$Result.GetResult<Prisma.$d_timePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more D_times that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_timeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all D_times
     * const d_times = await prisma.d_time.findMany()
     * 
     * // Get first 10 D_times
     * const d_times = await prisma.d_time.findMany({ take: 10 })
     * 
     * // Only select the `time`
     * const d_timeWithTimeOnly = await prisma.d_time.findMany({ select: { time: true } })
     * 
    **/
    findMany<T extends d_timeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, d_timeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$d_timePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a D_time.
     * @param {d_timeCreateArgs} args - Arguments to create a D_time.
     * @example
     * // Create one D_time
     * const D_time = await prisma.d_time.create({
     *   data: {
     *     // ... data to create a D_time
     *   }
     * })
     * 
    **/
    create<T extends d_timeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, d_timeCreateArgs<ExtArgs>>
    ): Prisma__d_timeClient<$Result.GetResult<Prisma.$d_timePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many D_times.
     *     @param {d_timeCreateManyArgs} args - Arguments to create many D_times.
     *     @example
     *     // Create many D_times
     *     const d_time = await prisma.d_time.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends d_timeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, d_timeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a D_time.
     * @param {d_timeDeleteArgs} args - Arguments to delete one D_time.
     * @example
     * // Delete one D_time
     * const D_time = await prisma.d_time.delete({
     *   where: {
     *     // ... filter to delete one D_time
     *   }
     * })
     * 
    **/
    delete<T extends d_timeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, d_timeDeleteArgs<ExtArgs>>
    ): Prisma__d_timeClient<$Result.GetResult<Prisma.$d_timePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one D_time.
     * @param {d_timeUpdateArgs} args - Arguments to update one D_time.
     * @example
     * // Update one D_time
     * const d_time = await prisma.d_time.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends d_timeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, d_timeUpdateArgs<ExtArgs>>
    ): Prisma__d_timeClient<$Result.GetResult<Prisma.$d_timePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more D_times.
     * @param {d_timeDeleteManyArgs} args - Arguments to filter D_times to delete.
     * @example
     * // Delete a few D_times
     * const { count } = await prisma.d_time.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends d_timeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, d_timeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more D_times.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_timeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many D_times
     * const d_time = await prisma.d_time.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends d_timeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, d_timeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one D_time.
     * @param {d_timeUpsertArgs} args - Arguments to update or create a D_time.
     * @example
     * // Update or create a D_time
     * const d_time = await prisma.d_time.upsert({
     *   create: {
     *     // ... data to create a D_time
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the D_time we want to update
     *   }
     * })
    **/
    upsert<T extends d_timeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, d_timeUpsertArgs<ExtArgs>>
    ): Prisma__d_timeClient<$Result.GetResult<Prisma.$d_timePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of D_times.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_timeCountArgs} args - Arguments to filter D_times to count.
     * @example
     * // Count the number of D_times
     * const count = await prisma.d_time.count({
     *   where: {
     *     // ... the filter for the D_times we want to count
     *   }
     * })
    **/
    count<T extends d_timeCountArgs>(
      args?: Subset<T, d_timeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], D_timeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a D_time.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {D_timeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends D_timeAggregateArgs>(args: Subset<T, D_timeAggregateArgs>): Prisma.PrismaPromise<GetD_timeAggregateType<T>>

    /**
     * Group by D_time.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_timeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends d_timeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: d_timeGroupByArgs['orderBy'] }
        : { orderBy?: d_timeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, d_timeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetD_timeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the d_time model
   */
  readonly fields: d_timeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for d_time.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__d_timeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the d_time model
   */ 
  interface d_timeFieldRefs {
    readonly time: FieldRef<"d_time", 'DateTime'>
    readonly hours: FieldRef<"d_time", 'Int'>
    readonly minutes: FieldRef<"d_time", 'Int'>
    readonly seconds: FieldRef<"d_time", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * d_time findUnique
   */
  export type d_timeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_time
     */
    select?: d_timeSelect<ExtArgs> | null
    /**
     * Filter, which d_time to fetch.
     */
    where: d_timeWhereUniqueInput
  }


  /**
   * d_time findUniqueOrThrow
   */
  export type d_timeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_time
     */
    select?: d_timeSelect<ExtArgs> | null
    /**
     * Filter, which d_time to fetch.
     */
    where: d_timeWhereUniqueInput
  }


  /**
   * d_time findFirst
   */
  export type d_timeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_time
     */
    select?: d_timeSelect<ExtArgs> | null
    /**
     * Filter, which d_time to fetch.
     */
    where?: d_timeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of d_times to fetch.
     */
    orderBy?: d_timeOrderByWithRelationInput | d_timeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for d_times.
     */
    cursor?: d_timeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` d_times from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` d_times.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of d_times.
     */
    distinct?: D_timeScalarFieldEnum | D_timeScalarFieldEnum[]
  }


  /**
   * d_time findFirstOrThrow
   */
  export type d_timeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_time
     */
    select?: d_timeSelect<ExtArgs> | null
    /**
     * Filter, which d_time to fetch.
     */
    where?: d_timeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of d_times to fetch.
     */
    orderBy?: d_timeOrderByWithRelationInput | d_timeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for d_times.
     */
    cursor?: d_timeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` d_times from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` d_times.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of d_times.
     */
    distinct?: D_timeScalarFieldEnum | D_timeScalarFieldEnum[]
  }


  /**
   * d_time findMany
   */
  export type d_timeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_time
     */
    select?: d_timeSelect<ExtArgs> | null
    /**
     * Filter, which d_times to fetch.
     */
    where?: d_timeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of d_times to fetch.
     */
    orderBy?: d_timeOrderByWithRelationInput | d_timeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing d_times.
     */
    cursor?: d_timeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` d_times from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` d_times.
     */
    skip?: number
    distinct?: D_timeScalarFieldEnum | D_timeScalarFieldEnum[]
  }


  /**
   * d_time create
   */
  export type d_timeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_time
     */
    select?: d_timeSelect<ExtArgs> | null
    /**
     * The data needed to create a d_time.
     */
    data: XOR<d_timeCreateInput, d_timeUncheckedCreateInput>
  }


  /**
   * d_time createMany
   */
  export type d_timeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many d_times.
     */
    data: d_timeCreateManyInput | d_timeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * d_time update
   */
  export type d_timeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_time
     */
    select?: d_timeSelect<ExtArgs> | null
    /**
     * The data needed to update a d_time.
     */
    data: XOR<d_timeUpdateInput, d_timeUncheckedUpdateInput>
    /**
     * Choose, which d_time to update.
     */
    where: d_timeWhereUniqueInput
  }


  /**
   * d_time updateMany
   */
  export type d_timeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update d_times.
     */
    data: XOR<d_timeUpdateManyMutationInput, d_timeUncheckedUpdateManyInput>
    /**
     * Filter which d_times to update
     */
    where?: d_timeWhereInput
  }


  /**
   * d_time upsert
   */
  export type d_timeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_time
     */
    select?: d_timeSelect<ExtArgs> | null
    /**
     * The filter to search for the d_time to update in case it exists.
     */
    where: d_timeWhereUniqueInput
    /**
     * In case the d_time found by the `where` argument doesn't exist, create a new d_time with this data.
     */
    create: XOR<d_timeCreateInput, d_timeUncheckedCreateInput>
    /**
     * In case the d_time was found with the provided `where` argument, update it with this data.
     */
    update: XOR<d_timeUpdateInput, d_timeUncheckedUpdateInput>
  }


  /**
   * d_time delete
   */
  export type d_timeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_time
     */
    select?: d_timeSelect<ExtArgs> | null
    /**
     * Filter which d_time to delete.
     */
    where: d_timeWhereUniqueInput
  }


  /**
   * d_time deleteMany
   */
  export type d_timeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which d_times to delete
     */
    where?: d_timeWhereInput
  }


  /**
   * d_time without action
   */
  export type d_timeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_time
     */
    select?: d_timeSelect<ExtArgs> | null
  }



  /**
   * Model d_transaction
   */

  export type AggregateD_transaction = {
    _count: D_transactionCountAggregateOutputType | null
    _avg: D_transactionAvgAggregateOutputType | null
    _sum: D_transactionSumAggregateOutputType | null
    _min: D_transactionMinAggregateOutputType | null
    _max: D_transactionMaxAggregateOutputType | null
  }

  export type D_transactionAvgAggregateOutputType = {
    transaction_id: number | null
    nonce: number | null
    transaction_index: number | null
    value: Decimal | null
    gas: number | null
    gas_price: number | null
    receipt_cumulative_gas_used: number | null
    receipt_gas_used: number | null
    receipt_status: number | null
    block_number: number | null
    emission_by_transaction: number | null
    emission_by_balance: number | null
  }

  export type D_transactionSumAggregateOutputType = {
    transaction_id: bigint | null
    nonce: bigint | null
    transaction_index: bigint | null
    value: Decimal | null
    gas: bigint | null
    gas_price: bigint | null
    receipt_cumulative_gas_used: bigint | null
    receipt_gas_used: bigint | null
    receipt_status: bigint | null
    block_number: bigint | null
    emission_by_transaction: number | null
    emission_by_balance: number | null
  }

  export type D_transactionMinAggregateOutputType = {
    transaction_id: bigint | null
    hash: string | null
    nonce: bigint | null
    transaction_index: bigint | null
    from_address: string | null
    to_address: string | null
    value: Decimal | null
    gas: bigint | null
    gas_price: bigint | null
    input: string | null
    receipt_cumulative_gas_used: bigint | null
    receipt_gas_used: bigint | null
    receipt_contract_address: string | null
    receipt_status: bigint | null
    block_timestamp: Date | null
    block_number: bigint | null
    block_hash: string | null
    emission_by_transaction: number | null
    emission_by_balance: number | null
  }

  export type D_transactionMaxAggregateOutputType = {
    transaction_id: bigint | null
    hash: string | null
    nonce: bigint | null
    transaction_index: bigint | null
    from_address: string | null
    to_address: string | null
    value: Decimal | null
    gas: bigint | null
    gas_price: bigint | null
    input: string | null
    receipt_cumulative_gas_used: bigint | null
    receipt_gas_used: bigint | null
    receipt_contract_address: string | null
    receipt_status: bigint | null
    block_timestamp: Date | null
    block_number: bigint | null
    block_hash: string | null
    emission_by_transaction: number | null
    emission_by_balance: number | null
  }

  export type D_transactionCountAggregateOutputType = {
    transaction_id: number
    hash: number
    nonce: number
    transaction_index: number
    from_address: number
    to_address: number
    value: number
    gas: number
    gas_price: number
    input: number
    receipt_cumulative_gas_used: number
    receipt_gas_used: number
    receipt_contract_address: number
    receipt_status: number
    block_timestamp: number
    block_number: number
    block_hash: number
    emission_by_transaction: number
    emission_by_balance: number
    _all: number
  }


  export type D_transactionAvgAggregateInputType = {
    transaction_id?: true
    nonce?: true
    transaction_index?: true
    value?: true
    gas?: true
    gas_price?: true
    receipt_cumulative_gas_used?: true
    receipt_gas_used?: true
    receipt_status?: true
    block_number?: true
    emission_by_transaction?: true
    emission_by_balance?: true
  }

  export type D_transactionSumAggregateInputType = {
    transaction_id?: true
    nonce?: true
    transaction_index?: true
    value?: true
    gas?: true
    gas_price?: true
    receipt_cumulative_gas_used?: true
    receipt_gas_used?: true
    receipt_status?: true
    block_number?: true
    emission_by_transaction?: true
    emission_by_balance?: true
  }

  export type D_transactionMinAggregateInputType = {
    transaction_id?: true
    hash?: true
    nonce?: true
    transaction_index?: true
    from_address?: true
    to_address?: true
    value?: true
    gas?: true
    gas_price?: true
    input?: true
    receipt_cumulative_gas_used?: true
    receipt_gas_used?: true
    receipt_contract_address?: true
    receipt_status?: true
    block_timestamp?: true
    block_number?: true
    block_hash?: true
    emission_by_transaction?: true
    emission_by_balance?: true
  }

  export type D_transactionMaxAggregateInputType = {
    transaction_id?: true
    hash?: true
    nonce?: true
    transaction_index?: true
    from_address?: true
    to_address?: true
    value?: true
    gas?: true
    gas_price?: true
    input?: true
    receipt_cumulative_gas_used?: true
    receipt_gas_used?: true
    receipt_contract_address?: true
    receipt_status?: true
    block_timestamp?: true
    block_number?: true
    block_hash?: true
    emission_by_transaction?: true
    emission_by_balance?: true
  }

  export type D_transactionCountAggregateInputType = {
    transaction_id?: true
    hash?: true
    nonce?: true
    transaction_index?: true
    from_address?: true
    to_address?: true
    value?: true
    gas?: true
    gas_price?: true
    input?: true
    receipt_cumulative_gas_used?: true
    receipt_gas_used?: true
    receipt_contract_address?: true
    receipt_status?: true
    block_timestamp?: true
    block_number?: true
    block_hash?: true
    emission_by_transaction?: true
    emission_by_balance?: true
    _all?: true
  }

  export type D_transactionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which d_transaction to aggregate.
     */
    where?: d_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of d_transactions to fetch.
     */
    orderBy?: d_transactionOrderByWithRelationInput | d_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: d_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` d_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` d_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned d_transactions
    **/
    _count?: true | D_transactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: D_transactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: D_transactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: D_transactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: D_transactionMaxAggregateInputType
  }

  export type GetD_transactionAggregateType<T extends D_transactionAggregateArgs> = {
        [P in keyof T & keyof AggregateD_transaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateD_transaction[P]>
      : GetScalarType<T[P], AggregateD_transaction[P]>
  }




  export type d_transactionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: d_transactionWhereInput
    orderBy?: d_transactionOrderByWithAggregationInput | d_transactionOrderByWithAggregationInput[]
    by: D_transactionScalarFieldEnum[] | D_transactionScalarFieldEnum
    having?: d_transactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: D_transactionCountAggregateInputType | true
    _avg?: D_transactionAvgAggregateInputType
    _sum?: D_transactionSumAggregateInputType
    _min?: D_transactionMinAggregateInputType
    _max?: D_transactionMaxAggregateInputType
  }

  export type D_transactionGroupByOutputType = {
    transaction_id: bigint
    hash: string | null
    nonce: bigint | null
    transaction_index: bigint | null
    from_address: string | null
    to_address: string | null
    value: Decimal | null
    gas: bigint | null
    gas_price: bigint | null
    input: string | null
    receipt_cumulative_gas_used: bigint | null
    receipt_gas_used: bigint | null
    receipt_contract_address: string | null
    receipt_status: bigint | null
    block_timestamp: Date | null
    block_number: bigint | null
    block_hash: string | null
    emission_by_transaction: number | null
    emission_by_balance: number | null
    _count: D_transactionCountAggregateOutputType | null
    _avg: D_transactionAvgAggregateOutputType | null
    _sum: D_transactionSumAggregateOutputType | null
    _min: D_transactionMinAggregateOutputType | null
    _max: D_transactionMaxAggregateOutputType | null
  }

  type GetD_transactionGroupByPayload<T extends d_transactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<D_transactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof D_transactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], D_transactionGroupByOutputType[P]>
            : GetScalarType<T[P], D_transactionGroupByOutputType[P]>
        }
      >
    >


  export type d_transactionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    transaction_id?: boolean
    hash?: boolean
    nonce?: boolean
    transaction_index?: boolean
    from_address?: boolean
    to_address?: boolean
    value?: boolean
    gas?: boolean
    gas_price?: boolean
    input?: boolean
    receipt_cumulative_gas_used?: boolean
    receipt_gas_used?: boolean
    receipt_contract_address?: boolean
    receipt_status?: boolean
    block_timestamp?: boolean
    block_number?: boolean
    block_hash?: boolean
    emission_by_transaction?: boolean
    emission_by_balance?: boolean
  }, ExtArgs["result"]["d_transaction"]>

  export type d_transactionSelectScalar = {
    transaction_id?: boolean
    hash?: boolean
    nonce?: boolean
    transaction_index?: boolean
    from_address?: boolean
    to_address?: boolean
    value?: boolean
    gas?: boolean
    gas_price?: boolean
    input?: boolean
    receipt_cumulative_gas_used?: boolean
    receipt_gas_used?: boolean
    receipt_contract_address?: boolean
    receipt_status?: boolean
    block_timestamp?: boolean
    block_number?: boolean
    block_hash?: boolean
    emission_by_transaction?: boolean
    emission_by_balance?: boolean
  }


  export type $d_transactionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "d_transaction"
    objects: {}
    scalars: $Extensions.GetResult<{
      transaction_id: bigint
      hash: string | null
      nonce: bigint | null
      transaction_index: bigint | null
      from_address: string | null
      to_address: string | null
      value: Prisma.Decimal | null
      gas: bigint | null
      gas_price: bigint | null
      input: string | null
      receipt_cumulative_gas_used: bigint | null
      receipt_gas_used: bigint | null
      receipt_contract_address: string | null
      receipt_status: bigint | null
      block_timestamp: Date | null
      block_number: bigint | null
      block_hash: string | null
      emission_by_transaction: number | null
      emission_by_balance: number | null
    }, ExtArgs["result"]["d_transaction"]>
    composites: {}
  }


  type d_transactionGetPayload<S extends boolean | null | undefined | d_transactionDefaultArgs> = $Result.GetResult<Prisma.$d_transactionPayload, S>

  type d_transactionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<d_transactionFindManyArgs, 'select' | 'include'> & {
      select?: D_transactionCountAggregateInputType | true
    }

  export interface d_transactionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['d_transaction'], meta: { name: 'd_transaction' } }
    /**
     * Find zero or one D_transaction that matches the filter.
     * @param {d_transactionFindUniqueArgs} args - Arguments to find a D_transaction
     * @example
     * // Get one D_transaction
     * const d_transaction = await prisma.d_transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends d_transactionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, d_transactionFindUniqueArgs<ExtArgs>>
    ): Prisma__d_transactionClient<$Result.GetResult<Prisma.$d_transactionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one D_transaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {d_transactionFindUniqueOrThrowArgs} args - Arguments to find a D_transaction
     * @example
     * // Get one D_transaction
     * const d_transaction = await prisma.d_transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends d_transactionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, d_transactionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__d_transactionClient<$Result.GetResult<Prisma.$d_transactionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first D_transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_transactionFindFirstArgs} args - Arguments to find a D_transaction
     * @example
     * // Get one D_transaction
     * const d_transaction = await prisma.d_transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends d_transactionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, d_transactionFindFirstArgs<ExtArgs>>
    ): Prisma__d_transactionClient<$Result.GetResult<Prisma.$d_transactionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first D_transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_transactionFindFirstOrThrowArgs} args - Arguments to find a D_transaction
     * @example
     * // Get one D_transaction
     * const d_transaction = await prisma.d_transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends d_transactionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, d_transactionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__d_transactionClient<$Result.GetResult<Prisma.$d_transactionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more D_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_transactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all D_transactions
     * const d_transactions = await prisma.d_transaction.findMany()
     * 
     * // Get first 10 D_transactions
     * const d_transactions = await prisma.d_transaction.findMany({ take: 10 })
     * 
     * // Only select the `transaction_id`
     * const d_transactionWithTransaction_idOnly = await prisma.d_transaction.findMany({ select: { transaction_id: true } })
     * 
    **/
    findMany<T extends d_transactionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, d_transactionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$d_transactionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a D_transaction.
     * @param {d_transactionCreateArgs} args - Arguments to create a D_transaction.
     * @example
     * // Create one D_transaction
     * const D_transaction = await prisma.d_transaction.create({
     *   data: {
     *     // ... data to create a D_transaction
     *   }
     * })
     * 
    **/
    create<T extends d_transactionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, d_transactionCreateArgs<ExtArgs>>
    ): Prisma__d_transactionClient<$Result.GetResult<Prisma.$d_transactionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many D_transactions.
     *     @param {d_transactionCreateManyArgs} args - Arguments to create many D_transactions.
     *     @example
     *     // Create many D_transactions
     *     const d_transaction = await prisma.d_transaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends d_transactionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, d_transactionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a D_transaction.
     * @param {d_transactionDeleteArgs} args - Arguments to delete one D_transaction.
     * @example
     * // Delete one D_transaction
     * const D_transaction = await prisma.d_transaction.delete({
     *   where: {
     *     // ... filter to delete one D_transaction
     *   }
     * })
     * 
    **/
    delete<T extends d_transactionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, d_transactionDeleteArgs<ExtArgs>>
    ): Prisma__d_transactionClient<$Result.GetResult<Prisma.$d_transactionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one D_transaction.
     * @param {d_transactionUpdateArgs} args - Arguments to update one D_transaction.
     * @example
     * // Update one D_transaction
     * const d_transaction = await prisma.d_transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends d_transactionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, d_transactionUpdateArgs<ExtArgs>>
    ): Prisma__d_transactionClient<$Result.GetResult<Prisma.$d_transactionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more D_transactions.
     * @param {d_transactionDeleteManyArgs} args - Arguments to filter D_transactions to delete.
     * @example
     * // Delete a few D_transactions
     * const { count } = await prisma.d_transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends d_transactionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, d_transactionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more D_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_transactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many D_transactions
     * const d_transaction = await prisma.d_transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends d_transactionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, d_transactionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one D_transaction.
     * @param {d_transactionUpsertArgs} args - Arguments to update or create a D_transaction.
     * @example
     * // Update or create a D_transaction
     * const d_transaction = await prisma.d_transaction.upsert({
     *   create: {
     *     // ... data to create a D_transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the D_transaction we want to update
     *   }
     * })
    **/
    upsert<T extends d_transactionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, d_transactionUpsertArgs<ExtArgs>>
    ): Prisma__d_transactionClient<$Result.GetResult<Prisma.$d_transactionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of D_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_transactionCountArgs} args - Arguments to filter D_transactions to count.
     * @example
     * // Count the number of D_transactions
     * const count = await prisma.d_transaction.count({
     *   where: {
     *     // ... the filter for the D_transactions we want to count
     *   }
     * })
    **/
    count<T extends d_transactionCountArgs>(
      args?: Subset<T, d_transactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], D_transactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a D_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {D_transactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends D_transactionAggregateArgs>(args: Subset<T, D_transactionAggregateArgs>): Prisma.PrismaPromise<GetD_transactionAggregateType<T>>

    /**
     * Group by D_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {d_transactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends d_transactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: d_transactionGroupByArgs['orderBy'] }
        : { orderBy?: d_transactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, d_transactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetD_transactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the d_transaction model
   */
  readonly fields: d_transactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for d_transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__d_transactionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the d_transaction model
   */ 
  interface d_transactionFieldRefs {
    readonly transaction_id: FieldRef<"d_transaction", 'BigInt'>
    readonly hash: FieldRef<"d_transaction", 'String'>
    readonly nonce: FieldRef<"d_transaction", 'BigInt'>
    readonly transaction_index: FieldRef<"d_transaction", 'BigInt'>
    readonly from_address: FieldRef<"d_transaction", 'String'>
    readonly to_address: FieldRef<"d_transaction", 'String'>
    readonly value: FieldRef<"d_transaction", 'Decimal'>
    readonly gas: FieldRef<"d_transaction", 'BigInt'>
    readonly gas_price: FieldRef<"d_transaction", 'BigInt'>
    readonly input: FieldRef<"d_transaction", 'String'>
    readonly receipt_cumulative_gas_used: FieldRef<"d_transaction", 'BigInt'>
    readonly receipt_gas_used: FieldRef<"d_transaction", 'BigInt'>
    readonly receipt_contract_address: FieldRef<"d_transaction", 'String'>
    readonly receipt_status: FieldRef<"d_transaction", 'BigInt'>
    readonly block_timestamp: FieldRef<"d_transaction", 'DateTime'>
    readonly block_number: FieldRef<"d_transaction", 'BigInt'>
    readonly block_hash: FieldRef<"d_transaction", 'String'>
    readonly emission_by_transaction: FieldRef<"d_transaction", 'Float'>
    readonly emission_by_balance: FieldRef<"d_transaction", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * d_transaction findUnique
   */
  export type d_transactionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_transaction
     */
    select?: d_transactionSelect<ExtArgs> | null
    /**
     * Filter, which d_transaction to fetch.
     */
    where: d_transactionWhereUniqueInput
  }


  /**
   * d_transaction findUniqueOrThrow
   */
  export type d_transactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_transaction
     */
    select?: d_transactionSelect<ExtArgs> | null
    /**
     * Filter, which d_transaction to fetch.
     */
    where: d_transactionWhereUniqueInput
  }


  /**
   * d_transaction findFirst
   */
  export type d_transactionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_transaction
     */
    select?: d_transactionSelect<ExtArgs> | null
    /**
     * Filter, which d_transaction to fetch.
     */
    where?: d_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of d_transactions to fetch.
     */
    orderBy?: d_transactionOrderByWithRelationInput | d_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for d_transactions.
     */
    cursor?: d_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` d_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` d_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of d_transactions.
     */
    distinct?: D_transactionScalarFieldEnum | D_transactionScalarFieldEnum[]
  }


  /**
   * d_transaction findFirstOrThrow
   */
  export type d_transactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_transaction
     */
    select?: d_transactionSelect<ExtArgs> | null
    /**
     * Filter, which d_transaction to fetch.
     */
    where?: d_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of d_transactions to fetch.
     */
    orderBy?: d_transactionOrderByWithRelationInput | d_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for d_transactions.
     */
    cursor?: d_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` d_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` d_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of d_transactions.
     */
    distinct?: D_transactionScalarFieldEnum | D_transactionScalarFieldEnum[]
  }


  /**
   * d_transaction findMany
   */
  export type d_transactionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_transaction
     */
    select?: d_transactionSelect<ExtArgs> | null
    /**
     * Filter, which d_transactions to fetch.
     */
    where?: d_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of d_transactions to fetch.
     */
    orderBy?: d_transactionOrderByWithRelationInput | d_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing d_transactions.
     */
    cursor?: d_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` d_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` d_transactions.
     */
    skip?: number
    distinct?: D_transactionScalarFieldEnum | D_transactionScalarFieldEnum[]
  }


  /**
   * d_transaction create
   */
  export type d_transactionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_transaction
     */
    select?: d_transactionSelect<ExtArgs> | null
    /**
     * The data needed to create a d_transaction.
     */
    data?: XOR<d_transactionCreateInput, d_transactionUncheckedCreateInput>
  }


  /**
   * d_transaction createMany
   */
  export type d_transactionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many d_transactions.
     */
    data: d_transactionCreateManyInput | d_transactionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * d_transaction update
   */
  export type d_transactionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_transaction
     */
    select?: d_transactionSelect<ExtArgs> | null
    /**
     * The data needed to update a d_transaction.
     */
    data: XOR<d_transactionUpdateInput, d_transactionUncheckedUpdateInput>
    /**
     * Choose, which d_transaction to update.
     */
    where: d_transactionWhereUniqueInput
  }


  /**
   * d_transaction updateMany
   */
  export type d_transactionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update d_transactions.
     */
    data: XOR<d_transactionUpdateManyMutationInput, d_transactionUncheckedUpdateManyInput>
    /**
     * Filter which d_transactions to update
     */
    where?: d_transactionWhereInput
  }


  /**
   * d_transaction upsert
   */
  export type d_transactionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_transaction
     */
    select?: d_transactionSelect<ExtArgs> | null
    /**
     * The filter to search for the d_transaction to update in case it exists.
     */
    where: d_transactionWhereUniqueInput
    /**
     * In case the d_transaction found by the `where` argument doesn't exist, create a new d_transaction with this data.
     */
    create: XOR<d_transactionCreateInput, d_transactionUncheckedCreateInput>
    /**
     * In case the d_transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<d_transactionUpdateInput, d_transactionUncheckedUpdateInput>
  }


  /**
   * d_transaction delete
   */
  export type d_transactionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_transaction
     */
    select?: d_transactionSelect<ExtArgs> | null
    /**
     * Filter which d_transaction to delete.
     */
    where: d_transactionWhereUniqueInput
  }


  /**
   * d_transaction deleteMany
   */
  export type d_transactionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which d_transactions to delete
     */
    where?: d_transactionWhereInput
  }


  /**
   * d_transaction without action
   */
  export type d_transactionDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the d_transaction
     */
    select?: d_transactionSelect<ExtArgs> | null
  }



  /**
   * Model token_transfers
   */

  export type AggregateToken_transfers = {
    _count: Token_transfersCountAggregateOutputType | null
    _avg: Token_transfersAvgAggregateOutputType | null
    _sum: Token_transfersSumAggregateOutputType | null
    _min: Token_transfersMinAggregateOutputType | null
    _max: Token_transfersMaxAggregateOutputType | null
  }

  export type Token_transfersAvgAggregateOutputType = {
    value: Decimal | null
    log_index: number | null
    block_number: number | null
  }

  export type Token_transfersSumAggregateOutputType = {
    value: Decimal | null
    log_index: bigint | null
    block_number: bigint | null
  }

  export type Token_transfersMinAggregateOutputType = {
    token_address: string | null
    from_address: string | null
    to_address: string | null
    value: Decimal | null
    transaction_hash: string | null
    log_index: bigint | null
    block_timestamp: Date | null
    block_number: bigint | null
    block_hash: string | null
  }

  export type Token_transfersMaxAggregateOutputType = {
    token_address: string | null
    from_address: string | null
    to_address: string | null
    value: Decimal | null
    transaction_hash: string | null
    log_index: bigint | null
    block_timestamp: Date | null
    block_number: bigint | null
    block_hash: string | null
  }

  export type Token_transfersCountAggregateOutputType = {
    token_address: number
    from_address: number
    to_address: number
    value: number
    transaction_hash: number
    log_index: number
    block_timestamp: number
    block_number: number
    block_hash: number
    _all: number
  }


  export type Token_transfersAvgAggregateInputType = {
    value?: true
    log_index?: true
    block_number?: true
  }

  export type Token_transfersSumAggregateInputType = {
    value?: true
    log_index?: true
    block_number?: true
  }

  export type Token_transfersMinAggregateInputType = {
    token_address?: true
    from_address?: true
    to_address?: true
    value?: true
    transaction_hash?: true
    log_index?: true
    block_timestamp?: true
    block_number?: true
    block_hash?: true
  }

  export type Token_transfersMaxAggregateInputType = {
    token_address?: true
    from_address?: true
    to_address?: true
    value?: true
    transaction_hash?: true
    log_index?: true
    block_timestamp?: true
    block_number?: true
    block_hash?: true
  }

  export type Token_transfersCountAggregateInputType = {
    token_address?: true
    from_address?: true
    to_address?: true
    value?: true
    transaction_hash?: true
    log_index?: true
    block_timestamp?: true
    block_number?: true
    block_hash?: true
    _all?: true
  }

  export type Token_transfersAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which token_transfers to aggregate.
     */
    where?: token_transfersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_transfers to fetch.
     */
    orderBy?: token_transfersOrderByWithRelationInput | token_transfersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: token_transfersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned token_transfers
    **/
    _count?: true | Token_transfersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Token_transfersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Token_transfersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Token_transfersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Token_transfersMaxAggregateInputType
  }

  export type GetToken_transfersAggregateType<T extends Token_transfersAggregateArgs> = {
        [P in keyof T & keyof AggregateToken_transfers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken_transfers[P]>
      : GetScalarType<T[P], AggregateToken_transfers[P]>
  }




  export type token_transfersGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: token_transfersWhereInput
    orderBy?: token_transfersOrderByWithAggregationInput | token_transfersOrderByWithAggregationInput[]
    by: Token_transfersScalarFieldEnum[] | Token_transfersScalarFieldEnum
    having?: token_transfersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Token_transfersCountAggregateInputType | true
    _avg?: Token_transfersAvgAggregateInputType
    _sum?: Token_transfersSumAggregateInputType
    _min?: Token_transfersMinAggregateInputType
    _max?: Token_transfersMaxAggregateInputType
  }

  export type Token_transfersGroupByOutputType = {
    token_address: string | null
    from_address: string | null
    to_address: string | null
    value: Decimal | null
    transaction_hash: string
    log_index: bigint
    block_timestamp: Date | null
    block_number: bigint | null
    block_hash: string | null
    _count: Token_transfersCountAggregateOutputType | null
    _avg: Token_transfersAvgAggregateOutputType | null
    _sum: Token_transfersSumAggregateOutputType | null
    _min: Token_transfersMinAggregateOutputType | null
    _max: Token_transfersMaxAggregateOutputType | null
  }

  type GetToken_transfersGroupByPayload<T extends token_transfersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Token_transfersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Token_transfersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Token_transfersGroupByOutputType[P]>
            : GetScalarType<T[P], Token_transfersGroupByOutputType[P]>
        }
      >
    >


  export type token_transfersSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    token_address?: boolean
    from_address?: boolean
    to_address?: boolean
    value?: boolean
    transaction_hash?: boolean
    log_index?: boolean
    block_timestamp?: boolean
    block_number?: boolean
    block_hash?: boolean
  }, ExtArgs["result"]["token_transfers"]>

  export type token_transfersSelectScalar = {
    token_address?: boolean
    from_address?: boolean
    to_address?: boolean
    value?: boolean
    transaction_hash?: boolean
    log_index?: boolean
    block_timestamp?: boolean
    block_number?: boolean
    block_hash?: boolean
  }


  export type $token_transfersPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "token_transfers"
    objects: {}
    scalars: $Extensions.GetResult<{
      token_address: string | null
      from_address: string | null
      to_address: string | null
      value: Prisma.Decimal | null
      transaction_hash: string
      log_index: bigint
      block_timestamp: Date | null
      block_number: bigint | null
      block_hash: string | null
    }, ExtArgs["result"]["token_transfers"]>
    composites: {}
  }


  type token_transfersGetPayload<S extends boolean | null | undefined | token_transfersDefaultArgs> = $Result.GetResult<Prisma.$token_transfersPayload, S>

  type token_transfersCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<token_transfersFindManyArgs, 'select' | 'include'> & {
      select?: Token_transfersCountAggregateInputType | true
    }

  export interface token_transfersDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['token_transfers'], meta: { name: 'token_transfers' } }
    /**
     * Find zero or one Token_transfers that matches the filter.
     * @param {token_transfersFindUniqueArgs} args - Arguments to find a Token_transfers
     * @example
     * // Get one Token_transfers
     * const token_transfers = await prisma.token_transfers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends token_transfersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, token_transfersFindUniqueArgs<ExtArgs>>
    ): Prisma__token_transfersClient<$Result.GetResult<Prisma.$token_transfersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Token_transfers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {token_transfersFindUniqueOrThrowArgs} args - Arguments to find a Token_transfers
     * @example
     * // Get one Token_transfers
     * const token_transfers = await prisma.token_transfers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends token_transfersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, token_transfersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__token_transfersClient<$Result.GetResult<Prisma.$token_transfersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Token_transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_transfersFindFirstArgs} args - Arguments to find a Token_transfers
     * @example
     * // Get one Token_transfers
     * const token_transfers = await prisma.token_transfers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends token_transfersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, token_transfersFindFirstArgs<ExtArgs>>
    ): Prisma__token_transfersClient<$Result.GetResult<Prisma.$token_transfersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Token_transfers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_transfersFindFirstOrThrowArgs} args - Arguments to find a Token_transfers
     * @example
     * // Get one Token_transfers
     * const token_transfers = await prisma.token_transfers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends token_transfersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, token_transfersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__token_transfersClient<$Result.GetResult<Prisma.$token_transfersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Token_transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_transfersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Token_transfers
     * const token_transfers = await prisma.token_transfers.findMany()
     * 
     * // Get first 10 Token_transfers
     * const token_transfers = await prisma.token_transfers.findMany({ take: 10 })
     * 
     * // Only select the `token_address`
     * const token_transfersWithToken_addressOnly = await prisma.token_transfers.findMany({ select: { token_address: true } })
     * 
    **/
    findMany<T extends token_transfersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, token_transfersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$token_transfersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Token_transfers.
     * @param {token_transfersCreateArgs} args - Arguments to create a Token_transfers.
     * @example
     * // Create one Token_transfers
     * const Token_transfers = await prisma.token_transfers.create({
     *   data: {
     *     // ... data to create a Token_transfers
     *   }
     * })
     * 
    **/
    create<T extends token_transfersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, token_transfersCreateArgs<ExtArgs>>
    ): Prisma__token_transfersClient<$Result.GetResult<Prisma.$token_transfersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Token_transfers.
     *     @param {token_transfersCreateManyArgs} args - Arguments to create many Token_transfers.
     *     @example
     *     // Create many Token_transfers
     *     const token_transfers = await prisma.token_transfers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends token_transfersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, token_transfersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Token_transfers.
     * @param {token_transfersDeleteArgs} args - Arguments to delete one Token_transfers.
     * @example
     * // Delete one Token_transfers
     * const Token_transfers = await prisma.token_transfers.delete({
     *   where: {
     *     // ... filter to delete one Token_transfers
     *   }
     * })
     * 
    **/
    delete<T extends token_transfersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, token_transfersDeleteArgs<ExtArgs>>
    ): Prisma__token_transfersClient<$Result.GetResult<Prisma.$token_transfersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Token_transfers.
     * @param {token_transfersUpdateArgs} args - Arguments to update one Token_transfers.
     * @example
     * // Update one Token_transfers
     * const token_transfers = await prisma.token_transfers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends token_transfersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, token_transfersUpdateArgs<ExtArgs>>
    ): Prisma__token_transfersClient<$Result.GetResult<Prisma.$token_transfersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Token_transfers.
     * @param {token_transfersDeleteManyArgs} args - Arguments to filter Token_transfers to delete.
     * @example
     * // Delete a few Token_transfers
     * const { count } = await prisma.token_transfers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends token_transfersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, token_transfersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Token_transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_transfersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Token_transfers
     * const token_transfers = await prisma.token_transfers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends token_transfersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, token_transfersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Token_transfers.
     * @param {token_transfersUpsertArgs} args - Arguments to update or create a Token_transfers.
     * @example
     * // Update or create a Token_transfers
     * const token_transfers = await prisma.token_transfers.upsert({
     *   create: {
     *     // ... data to create a Token_transfers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token_transfers we want to update
     *   }
     * })
    **/
    upsert<T extends token_transfersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, token_transfersUpsertArgs<ExtArgs>>
    ): Prisma__token_transfersClient<$Result.GetResult<Prisma.$token_transfersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Token_transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_transfersCountArgs} args - Arguments to filter Token_transfers to count.
     * @example
     * // Count the number of Token_transfers
     * const count = await prisma.token_transfers.count({
     *   where: {
     *     // ... the filter for the Token_transfers we want to count
     *   }
     * })
    **/
    count<T extends token_transfersCountArgs>(
      args?: Subset<T, token_transfersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Token_transfersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token_transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Token_transfersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Token_transfersAggregateArgs>(args: Subset<T, Token_transfersAggregateArgs>): Prisma.PrismaPromise<GetToken_transfersAggregateType<T>>

    /**
     * Group by Token_transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_transfersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends token_transfersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: token_transfersGroupByArgs['orderBy'] }
        : { orderBy?: token_transfersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, token_transfersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetToken_transfersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the token_transfers model
   */
  readonly fields: token_transfersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for token_transfers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__token_transfersClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the token_transfers model
   */ 
  interface token_transfersFieldRefs {
    readonly token_address: FieldRef<"token_transfers", 'String'>
    readonly from_address: FieldRef<"token_transfers", 'String'>
    readonly to_address: FieldRef<"token_transfers", 'String'>
    readonly value: FieldRef<"token_transfers", 'Decimal'>
    readonly transaction_hash: FieldRef<"token_transfers", 'String'>
    readonly log_index: FieldRef<"token_transfers", 'BigInt'>
    readonly block_timestamp: FieldRef<"token_transfers", 'DateTime'>
    readonly block_number: FieldRef<"token_transfers", 'BigInt'>
    readonly block_hash: FieldRef<"token_transfers", 'String'>
  }
    

  // Custom InputTypes

  /**
   * token_transfers findUnique
   */
  export type token_transfersFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_transfers
     */
    select?: token_transfersSelect<ExtArgs> | null
    /**
     * Filter, which token_transfers to fetch.
     */
    where: token_transfersWhereUniqueInput
  }


  /**
   * token_transfers findUniqueOrThrow
   */
  export type token_transfersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_transfers
     */
    select?: token_transfersSelect<ExtArgs> | null
    /**
     * Filter, which token_transfers to fetch.
     */
    where: token_transfersWhereUniqueInput
  }


  /**
   * token_transfers findFirst
   */
  export type token_transfersFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_transfers
     */
    select?: token_transfersSelect<ExtArgs> | null
    /**
     * Filter, which token_transfers to fetch.
     */
    where?: token_transfersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_transfers to fetch.
     */
    orderBy?: token_transfersOrderByWithRelationInput | token_transfersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for token_transfers.
     */
    cursor?: token_transfersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of token_transfers.
     */
    distinct?: Token_transfersScalarFieldEnum | Token_transfersScalarFieldEnum[]
  }


  /**
   * token_transfers findFirstOrThrow
   */
  export type token_transfersFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_transfers
     */
    select?: token_transfersSelect<ExtArgs> | null
    /**
     * Filter, which token_transfers to fetch.
     */
    where?: token_transfersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_transfers to fetch.
     */
    orderBy?: token_transfersOrderByWithRelationInput | token_transfersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for token_transfers.
     */
    cursor?: token_transfersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of token_transfers.
     */
    distinct?: Token_transfersScalarFieldEnum | Token_transfersScalarFieldEnum[]
  }


  /**
   * token_transfers findMany
   */
  export type token_transfersFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_transfers
     */
    select?: token_transfersSelect<ExtArgs> | null
    /**
     * Filter, which token_transfers to fetch.
     */
    where?: token_transfersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_transfers to fetch.
     */
    orderBy?: token_transfersOrderByWithRelationInput | token_transfersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing token_transfers.
     */
    cursor?: token_transfersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_transfers.
     */
    skip?: number
    distinct?: Token_transfersScalarFieldEnum | Token_transfersScalarFieldEnum[]
  }


  /**
   * token_transfers create
   */
  export type token_transfersCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_transfers
     */
    select?: token_transfersSelect<ExtArgs> | null
    /**
     * The data needed to create a token_transfers.
     */
    data: XOR<token_transfersCreateInput, token_transfersUncheckedCreateInput>
  }


  /**
   * token_transfers createMany
   */
  export type token_transfersCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many token_transfers.
     */
    data: token_transfersCreateManyInput | token_transfersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * token_transfers update
   */
  export type token_transfersUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_transfers
     */
    select?: token_transfersSelect<ExtArgs> | null
    /**
     * The data needed to update a token_transfers.
     */
    data: XOR<token_transfersUpdateInput, token_transfersUncheckedUpdateInput>
    /**
     * Choose, which token_transfers to update.
     */
    where: token_transfersWhereUniqueInput
  }


  /**
   * token_transfers updateMany
   */
  export type token_transfersUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update token_transfers.
     */
    data: XOR<token_transfersUpdateManyMutationInput, token_transfersUncheckedUpdateManyInput>
    /**
     * Filter which token_transfers to update
     */
    where?: token_transfersWhereInput
  }


  /**
   * token_transfers upsert
   */
  export type token_transfersUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_transfers
     */
    select?: token_transfersSelect<ExtArgs> | null
    /**
     * The filter to search for the token_transfers to update in case it exists.
     */
    where: token_transfersWhereUniqueInput
    /**
     * In case the token_transfers found by the `where` argument doesn't exist, create a new token_transfers with this data.
     */
    create: XOR<token_transfersCreateInput, token_transfersUncheckedCreateInput>
    /**
     * In case the token_transfers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<token_transfersUpdateInput, token_transfersUncheckedUpdateInput>
  }


  /**
   * token_transfers delete
   */
  export type token_transfersDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_transfers
     */
    select?: token_transfersSelect<ExtArgs> | null
    /**
     * Filter which token_transfers to delete.
     */
    where: token_transfersWhereUniqueInput
  }


  /**
   * token_transfers deleteMany
   */
  export type token_transfersDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which token_transfers to delete
     */
    where?: token_transfersWhereInput
  }


  /**
   * token_transfers without action
   */
  export type token_transfersDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the token_transfers
     */
    select?: token_transfersSelect<ExtArgs> | null
  }



  /**
   * Model transactions
   */

  export type AggregateTransactions = {
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  export type TransactionsAvgAggregateOutputType = {
    nonce: number | null
    transaction_index: number | null
    value: Decimal | null
    gas: number | null
    gas_price: number | null
    receipt_cumulative_gas_used: number | null
    receipt_gas_used: number | null
    receipt_status: number | null
    block_number: number | null
    emission_by_transaction: number | null
    emission_by_balance: number | null
  }

  export type TransactionsSumAggregateOutputType = {
    nonce: bigint | null
    transaction_index: bigint | null
    value: Decimal | null
    gas: bigint | null
    gas_price: bigint | null
    receipt_cumulative_gas_used: bigint | null
    receipt_gas_used: bigint | null
    receipt_status: bigint | null
    block_number: bigint | null
    emission_by_transaction: number | null
    emission_by_balance: number | null
  }

  export type TransactionsMinAggregateOutputType = {
    hash: string | null
    nonce: bigint | null
    transaction_index: bigint | null
    from_address: string | null
    to_address: string | null
    value: Decimal | null
    gas: bigint | null
    gas_price: bigint | null
    input: string | null
    receipt_cumulative_gas_used: bigint | null
    receipt_gas_used: bigint | null
    receipt_contract_address: string | null
    receipt_root: string | null
    receipt_status: bigint | null
    block_timestamp: Date | null
    block_number: bigint | null
    block_hash: string | null
    emission_by_transaction: number | null
    emission_by_balance: number | null
  }

  export type TransactionsMaxAggregateOutputType = {
    hash: string | null
    nonce: bigint | null
    transaction_index: bigint | null
    from_address: string | null
    to_address: string | null
    value: Decimal | null
    gas: bigint | null
    gas_price: bigint | null
    input: string | null
    receipt_cumulative_gas_used: bigint | null
    receipt_gas_used: bigint | null
    receipt_contract_address: string | null
    receipt_root: string | null
    receipt_status: bigint | null
    block_timestamp: Date | null
    block_number: bigint | null
    block_hash: string | null
    emission_by_transaction: number | null
    emission_by_balance: number | null
  }

  export type TransactionsCountAggregateOutputType = {
    hash: number
    nonce: number
    transaction_index: number
    from_address: number
    to_address: number
    value: number
    gas: number
    gas_price: number
    input: number
    receipt_cumulative_gas_used: number
    receipt_gas_used: number
    receipt_contract_address: number
    receipt_root: number
    receipt_status: number
    block_timestamp: number
    block_number: number
    block_hash: number
    emission_by_transaction: number
    emission_by_balance: number
    _all: number
  }


  export type TransactionsAvgAggregateInputType = {
    nonce?: true
    transaction_index?: true
    value?: true
    gas?: true
    gas_price?: true
    receipt_cumulative_gas_used?: true
    receipt_gas_used?: true
    receipt_status?: true
    block_number?: true
    emission_by_transaction?: true
    emission_by_balance?: true
  }

  export type TransactionsSumAggregateInputType = {
    nonce?: true
    transaction_index?: true
    value?: true
    gas?: true
    gas_price?: true
    receipt_cumulative_gas_used?: true
    receipt_gas_used?: true
    receipt_status?: true
    block_number?: true
    emission_by_transaction?: true
    emission_by_balance?: true
  }

  export type TransactionsMinAggregateInputType = {
    hash?: true
    nonce?: true
    transaction_index?: true
    from_address?: true
    to_address?: true
    value?: true
    gas?: true
    gas_price?: true
    input?: true
    receipt_cumulative_gas_used?: true
    receipt_gas_used?: true
    receipt_contract_address?: true
    receipt_root?: true
    receipt_status?: true
    block_timestamp?: true
    block_number?: true
    block_hash?: true
    emission_by_transaction?: true
    emission_by_balance?: true
  }

  export type TransactionsMaxAggregateInputType = {
    hash?: true
    nonce?: true
    transaction_index?: true
    from_address?: true
    to_address?: true
    value?: true
    gas?: true
    gas_price?: true
    input?: true
    receipt_cumulative_gas_used?: true
    receipt_gas_used?: true
    receipt_contract_address?: true
    receipt_root?: true
    receipt_status?: true
    block_timestamp?: true
    block_number?: true
    block_hash?: true
    emission_by_transaction?: true
    emission_by_balance?: true
  }

  export type TransactionsCountAggregateInputType = {
    hash?: true
    nonce?: true
    transaction_index?: true
    from_address?: true
    to_address?: true
    value?: true
    gas?: true
    gas_price?: true
    input?: true
    receipt_cumulative_gas_used?: true
    receipt_gas_used?: true
    receipt_contract_address?: true
    receipt_root?: true
    receipt_status?: true
    block_timestamp?: true
    block_number?: true
    block_hash?: true
    emission_by_transaction?: true
    emission_by_balance?: true
    _all?: true
  }

  export type TransactionsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactions to aggregate.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactions
    **/
    _count?: true | TransactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionsMaxAggregateInputType
  }

  export type GetTransactionsAggregateType<T extends TransactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactions[P]>
      : GetScalarType<T[P], AggregateTransactions[P]>
  }




  export type transactionsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: transactionsWhereInput
    orderBy?: transactionsOrderByWithAggregationInput | transactionsOrderByWithAggregationInput[]
    by: TransactionsScalarFieldEnum[] | TransactionsScalarFieldEnum
    having?: transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionsCountAggregateInputType | true
    _avg?: TransactionsAvgAggregateInputType
    _sum?: TransactionsSumAggregateInputType
    _min?: TransactionsMinAggregateInputType
    _max?: TransactionsMaxAggregateInputType
  }

  export type TransactionsGroupByOutputType = {
    hash: string
    nonce: bigint | null
    transaction_index: bigint | null
    from_address: string | null
    to_address: string | null
    value: Decimal | null
    gas: bigint | null
    gas_price: bigint | null
    input: string | null
    receipt_cumulative_gas_used: bigint | null
    receipt_gas_used: bigint | null
    receipt_contract_address: string | null
    receipt_root: string | null
    receipt_status: bigint | null
    block_timestamp: Date | null
    block_number: bigint | null
    block_hash: string | null
    emission_by_transaction: number | null
    emission_by_balance: number | null
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  type GetTransactionsGroupByPayload<T extends transactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
        }
      >
    >


  export type transactionsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hash?: boolean
    nonce?: boolean
    transaction_index?: boolean
    from_address?: boolean
    to_address?: boolean
    value?: boolean
    gas?: boolean
    gas_price?: boolean
    input?: boolean
    receipt_cumulative_gas_used?: boolean
    receipt_gas_used?: boolean
    receipt_contract_address?: boolean
    receipt_root?: boolean
    receipt_status?: boolean
    block_timestamp?: boolean
    block_number?: boolean
    block_hash?: boolean
    emission_by_transaction?: boolean
    emission_by_balance?: boolean
  }, ExtArgs["result"]["transactions"]>

  export type transactionsSelectScalar = {
    hash?: boolean
    nonce?: boolean
    transaction_index?: boolean
    from_address?: boolean
    to_address?: boolean
    value?: boolean
    gas?: boolean
    gas_price?: boolean
    input?: boolean
    receipt_cumulative_gas_used?: boolean
    receipt_gas_used?: boolean
    receipt_contract_address?: boolean
    receipt_root?: boolean
    receipt_status?: boolean
    block_timestamp?: boolean
    block_number?: boolean
    block_hash?: boolean
    emission_by_transaction?: boolean
    emission_by_balance?: boolean
  }


  export type $transactionsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "transactions"
    objects: {}
    scalars: $Extensions.GetResult<{
      hash: string
      nonce: bigint | null
      transaction_index: bigint | null
      from_address: string | null
      to_address: string | null
      value: Prisma.Decimal | null
      gas: bigint | null
      gas_price: bigint | null
      input: string | null
      receipt_cumulative_gas_used: bigint | null
      receipt_gas_used: bigint | null
      receipt_contract_address: string | null
      receipt_root: string | null
      receipt_status: bigint | null
      block_timestamp: Date | null
      block_number: bigint | null
      block_hash: string | null
      emission_by_transaction: number | null
      emission_by_balance: number | null
    }, ExtArgs["result"]["transactions"]>
    composites: {}
  }


  type transactionsGetPayload<S extends boolean | null | undefined | transactionsDefaultArgs> = $Result.GetResult<Prisma.$transactionsPayload, S>

  type transactionsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<transactionsFindManyArgs, 'select' | 'include'> & {
      select?: TransactionsCountAggregateInputType | true
    }

  export interface transactionsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transactions'], meta: { name: 'transactions' } }
    /**
     * Find zero or one Transactions that matches the filter.
     * @param {transactionsFindUniqueArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends transactionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, transactionsFindUniqueArgs<ExtArgs>>
    ): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Transactions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {transactionsFindUniqueOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends transactionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, transactionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindFirstArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends transactionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, transactionsFindFirstArgs<ExtArgs>>
    ): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindFirstOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends transactionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, transactionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transactions.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transactions.findMany({ take: 10 })
     * 
     * // Only select the `hash`
     * const transactionsWithHashOnly = await prisma.transactions.findMany({ select: { hash: true } })
     * 
    **/
    findMany<T extends transactionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, transactionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Transactions.
     * @param {transactionsCreateArgs} args - Arguments to create a Transactions.
     * @example
     * // Create one Transactions
     * const Transactions = await prisma.transactions.create({
     *   data: {
     *     // ... data to create a Transactions
     *   }
     * })
     * 
    **/
    create<T extends transactionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, transactionsCreateArgs<ExtArgs>>
    ): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Transactions.
     *     @param {transactionsCreateManyArgs} args - Arguments to create many Transactions.
     *     @example
     *     // Create many Transactions
     *     const transactions = await prisma.transactions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends transactionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, transactionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transactions.
     * @param {transactionsDeleteArgs} args - Arguments to delete one Transactions.
     * @example
     * // Delete one Transactions
     * const Transactions = await prisma.transactions.delete({
     *   where: {
     *     // ... filter to delete one Transactions
     *   }
     * })
     * 
    **/
    delete<T extends transactionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, transactionsDeleteArgs<ExtArgs>>
    ): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Transactions.
     * @param {transactionsUpdateArgs} args - Arguments to update one Transactions.
     * @example
     * // Update one Transactions
     * const transactions = await prisma.transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends transactionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, transactionsUpdateArgs<ExtArgs>>
    ): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {transactionsDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends transactionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, transactionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends transactionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, transactionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transactions.
     * @param {transactionsUpsertArgs} args - Arguments to update or create a Transactions.
     * @example
     * // Update or create a Transactions
     * const transactions = await prisma.transactions.upsert({
     *   create: {
     *     // ... data to create a Transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transactions we want to update
     *   }
     * })
    **/
    upsert<T extends transactionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, transactionsUpsertArgs<ExtArgs>>
    ): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transactions.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends transactionsCountArgs>(
      args?: Subset<T, transactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionsAggregateArgs>(args: Subset<T, TransactionsAggregateArgs>): Prisma.PrismaPromise<GetTransactionsAggregateType<T>>

    /**
     * Group by Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transactionsGroupByArgs['orderBy'] }
        : { orderBy?: transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transactions model
   */
  readonly fields: transactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transactionsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the transactions model
   */ 
  interface transactionsFieldRefs {
    readonly hash: FieldRef<"transactions", 'String'>
    readonly nonce: FieldRef<"transactions", 'BigInt'>
    readonly transaction_index: FieldRef<"transactions", 'BigInt'>
    readonly from_address: FieldRef<"transactions", 'String'>
    readonly to_address: FieldRef<"transactions", 'String'>
    readonly value: FieldRef<"transactions", 'Decimal'>
    readonly gas: FieldRef<"transactions", 'BigInt'>
    readonly gas_price: FieldRef<"transactions", 'BigInt'>
    readonly input: FieldRef<"transactions", 'String'>
    readonly receipt_cumulative_gas_used: FieldRef<"transactions", 'BigInt'>
    readonly receipt_gas_used: FieldRef<"transactions", 'BigInt'>
    readonly receipt_contract_address: FieldRef<"transactions", 'String'>
    readonly receipt_root: FieldRef<"transactions", 'String'>
    readonly receipt_status: FieldRef<"transactions", 'BigInt'>
    readonly block_timestamp: FieldRef<"transactions", 'DateTime'>
    readonly block_number: FieldRef<"transactions", 'BigInt'>
    readonly block_hash: FieldRef<"transactions", 'String'>
    readonly emission_by_transaction: FieldRef<"transactions", 'Float'>
    readonly emission_by_balance: FieldRef<"transactions", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * transactions findUnique
   */
  export type transactionsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where: transactionsWhereUniqueInput
  }


  /**
   * transactions findUniqueOrThrow
   */
  export type transactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where: transactionsWhereUniqueInput
  }


  /**
   * transactions findFirst
   */
  export type transactionsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }


  /**
   * transactions findFirstOrThrow
   */
  export type transactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }


  /**
   * transactions findMany
   */
  export type transactionsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }


  /**
   * transactions create
   */
  export type transactionsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * The data needed to create a transactions.
     */
    data: XOR<transactionsCreateInput, transactionsUncheckedCreateInput>
  }


  /**
   * transactions createMany
   */
  export type transactionsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transactions.
     */
    data: transactionsCreateManyInput | transactionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * transactions update
   */
  export type transactionsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * The data needed to update a transactions.
     */
    data: XOR<transactionsUpdateInput, transactionsUncheckedUpdateInput>
    /**
     * Choose, which transactions to update.
     */
    where: transactionsWhereUniqueInput
  }


  /**
   * transactions updateMany
   */
  export type transactionsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionsWhereInput
  }


  /**
   * transactions upsert
   */
  export type transactionsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * The filter to search for the transactions to update in case it exists.
     */
    where: transactionsWhereUniqueInput
    /**
     * In case the transactions found by the `where` argument doesn't exist, create a new transactions with this data.
     */
    create: XOR<transactionsCreateInput, transactionsUncheckedCreateInput>
    /**
     * In case the transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionsUpdateInput, transactionsUncheckedUpdateInput>
  }


  /**
   * transactions delete
   */
  export type transactionsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Filter which transactions to delete.
     */
    where: transactionsWhereUniqueInput
  }


  /**
   * transactions deleteMany
   */
  export type transactionsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactions to delete
     */
    where?: transactionsWhereInput
  }


  /**
   * transactions without action
   */
  export type transactionsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BlocksScalarFieldEnum: {
    number: 'number',
    hash: 'hash',
    parent_hash: 'parent_hash',
    nonce: 'nonce',
    logs_bloom: 'logs_bloom',
    transactions_root: 'transactions_root',
    state_root: 'state_root',
    receipts_root: 'receipts_root',
    fee_recipient: 'fee_recipient',
    proposer_index: 'proposer_index',
    gas_limit: 'gas_limit',
    gas_used: 'gas_used',
    timestamp: 'timestamp',
    transaction_count: 'transaction_count'
  };

  export type BlocksScalarFieldEnum = (typeof BlocksScalarFieldEnum)[keyof typeof BlocksScalarFieldEnum]


  export const D_accountScalarFieldEnum: {
    account_id: 'account_id',
    address: 'address',
    eth_sent: 'eth_sent',
    eth_received: 'eth_received',
    account_balance: 'account_balance'
  };

  export type D_accountScalarFieldEnum = (typeof D_accountScalarFieldEnum)[keyof typeof D_accountScalarFieldEnum]


  export const D_blockScalarFieldEnum: {
    block_id: 'block_id',
    timestamp: 'timestamp',
    number: 'number',
    hash: 'hash',
    parent_hash: 'parent_hash',
    fee_recipient: 'fee_recipient',
    logs_bloom: 'logs_bloom',
    transactions_root: 'transactions_root',
    state_root: 'state_root',
    proposer_index: 'proposer_index',
    gas_limit: 'gas_limit',
    gas_used: 'gas_used',
    transaction_count: 'transaction_count'
  };

  export type D_blockScalarFieldEnum = (typeof D_blockScalarFieldEnum)[keyof typeof D_blockScalarFieldEnum]


  export const D_dateScalarFieldEnum: {
    date: 'date',
    year: 'year',
    month: 'month',
    day: 'day',
    weekday: 'weekday',
    day_in_chars: 'day_in_chars',
    week: 'week'
  };

  export type D_dateScalarFieldEnum = (typeof D_dateScalarFieldEnum)[keyof typeof D_dateScalarFieldEnum]


  export const D_timeScalarFieldEnum: {
    time: 'time',
    hours: 'hours',
    minutes: 'minutes',
    seconds: 'seconds'
  };

  export type D_timeScalarFieldEnum = (typeof D_timeScalarFieldEnum)[keyof typeof D_timeScalarFieldEnum]


  export const D_transactionScalarFieldEnum: {
    transaction_id: 'transaction_id',
    hash: 'hash',
    nonce: 'nonce',
    transaction_index: 'transaction_index',
    from_address: 'from_address',
    to_address: 'to_address',
    value: 'value',
    gas: 'gas',
    gas_price: 'gas_price',
    input: 'input',
    receipt_cumulative_gas_used: 'receipt_cumulative_gas_used',
    receipt_gas_used: 'receipt_gas_used',
    receipt_contract_address: 'receipt_contract_address',
    receipt_status: 'receipt_status',
    block_timestamp: 'block_timestamp',
    block_number: 'block_number',
    block_hash: 'block_hash',
    emission_by_transaction: 'emission_by_transaction',
    emission_by_balance: 'emission_by_balance'
  };

  export type D_transactionScalarFieldEnum = (typeof D_transactionScalarFieldEnum)[keyof typeof D_transactionScalarFieldEnum]


  export const Token_transfersScalarFieldEnum: {
    token_address: 'token_address',
    from_address: 'from_address',
    to_address: 'to_address',
    value: 'value',
    transaction_hash: 'transaction_hash',
    log_index: 'log_index',
    block_timestamp: 'block_timestamp',
    block_number: 'block_number',
    block_hash: 'block_hash'
  };

  export type Token_transfersScalarFieldEnum = (typeof Token_transfersScalarFieldEnum)[keyof typeof Token_transfersScalarFieldEnum]


  export const TransactionsScalarFieldEnum: {
    hash: 'hash',
    nonce: 'nonce',
    transaction_index: 'transaction_index',
    from_address: 'from_address',
    to_address: 'to_address',
    value: 'value',
    gas: 'gas',
    gas_price: 'gas_price',
    input: 'input',
    receipt_cumulative_gas_used: 'receipt_cumulative_gas_used',
    receipt_gas_used: 'receipt_gas_used',
    receipt_contract_address: 'receipt_contract_address',
    receipt_root: 'receipt_root',
    receipt_status: 'receipt_status',
    block_timestamp: 'block_timestamp',
    block_number: 'block_number',
    block_hash: 'block_hash',
    emission_by_transaction: 'emission_by_transaction',
    emission_by_balance: 'emission_by_balance'
  };

  export type TransactionsScalarFieldEnum = (typeof TransactionsScalarFieldEnum)[keyof typeof TransactionsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    
  /**
   * Deep Input Types
   */


  export type blocksWhereInput = {
    AND?: blocksWhereInput | blocksWhereInput[]
    OR?: blocksWhereInput[]
    NOT?: blocksWhereInput | blocksWhereInput[]
    number?: BigIntNullableFilter<"blocks"> | bigint | number | null
    hash?: StringFilter<"blocks"> | string
    parent_hash?: StringNullableFilter<"blocks"> | string | null
    nonce?: StringNullableFilter<"blocks"> | string | null
    logs_bloom?: StringNullableFilter<"blocks"> | string | null
    transactions_root?: StringNullableFilter<"blocks"> | string | null
    state_root?: StringNullableFilter<"blocks"> | string | null
    receipts_root?: StringNullableFilter<"blocks"> | string | null
    fee_recipient?: StringNullableFilter<"blocks"> | string | null
    proposer_index?: BigIntNullableFilter<"blocks"> | bigint | number | null
    gas_limit?: BigIntNullableFilter<"blocks"> | bigint | number | null
    gas_used?: BigIntNullableFilter<"blocks"> | bigint | number | null
    timestamp?: DateTimeNullableFilter<"blocks"> | Date | string | null
    transaction_count?: BigIntNullableFilter<"blocks"> | bigint | number | null
  }

  export type blocksOrderByWithRelationInput = {
    number?: SortOrderInput | SortOrder
    hash?: SortOrder
    parent_hash?: SortOrderInput | SortOrder
    nonce?: SortOrderInput | SortOrder
    logs_bloom?: SortOrderInput | SortOrder
    transactions_root?: SortOrderInput | SortOrder
    state_root?: SortOrderInput | SortOrder
    receipts_root?: SortOrderInput | SortOrder
    fee_recipient?: SortOrderInput | SortOrder
    proposer_index?: SortOrderInput | SortOrder
    gas_limit?: SortOrderInput | SortOrder
    gas_used?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    transaction_count?: SortOrderInput | SortOrder
  }

  export type blocksWhereUniqueInput = Prisma.AtLeast<{
    hash?: string
    AND?: blocksWhereInput | blocksWhereInput[]
    OR?: blocksWhereInput[]
    NOT?: blocksWhereInput | blocksWhereInput[]
    number?: BigIntNullableFilter<"blocks"> | bigint | number | null
    parent_hash?: StringNullableFilter<"blocks"> | string | null
    nonce?: StringNullableFilter<"blocks"> | string | null
    logs_bloom?: StringNullableFilter<"blocks"> | string | null
    transactions_root?: StringNullableFilter<"blocks"> | string | null
    state_root?: StringNullableFilter<"blocks"> | string | null
    receipts_root?: StringNullableFilter<"blocks"> | string | null
    fee_recipient?: StringNullableFilter<"blocks"> | string | null
    proposer_index?: BigIntNullableFilter<"blocks"> | bigint | number | null
    gas_limit?: BigIntNullableFilter<"blocks"> | bigint | number | null
    gas_used?: BigIntNullableFilter<"blocks"> | bigint | number | null
    timestamp?: DateTimeNullableFilter<"blocks"> | Date | string | null
    transaction_count?: BigIntNullableFilter<"blocks"> | bigint | number | null
  }, "hash">

  export type blocksOrderByWithAggregationInput = {
    number?: SortOrderInput | SortOrder
    hash?: SortOrder
    parent_hash?: SortOrderInput | SortOrder
    nonce?: SortOrderInput | SortOrder
    logs_bloom?: SortOrderInput | SortOrder
    transactions_root?: SortOrderInput | SortOrder
    state_root?: SortOrderInput | SortOrder
    receipts_root?: SortOrderInput | SortOrder
    fee_recipient?: SortOrderInput | SortOrder
    proposer_index?: SortOrderInput | SortOrder
    gas_limit?: SortOrderInput | SortOrder
    gas_used?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    transaction_count?: SortOrderInput | SortOrder
    _count?: blocksCountOrderByAggregateInput
    _avg?: blocksAvgOrderByAggregateInput
    _max?: blocksMaxOrderByAggregateInput
    _min?: blocksMinOrderByAggregateInput
    _sum?: blocksSumOrderByAggregateInput
  }

  export type blocksScalarWhereWithAggregatesInput = {
    AND?: blocksScalarWhereWithAggregatesInput | blocksScalarWhereWithAggregatesInput[]
    OR?: blocksScalarWhereWithAggregatesInput[]
    NOT?: blocksScalarWhereWithAggregatesInput | blocksScalarWhereWithAggregatesInput[]
    number?: BigIntNullableWithAggregatesFilter<"blocks"> | bigint | number | null
    hash?: StringWithAggregatesFilter<"blocks"> | string
    parent_hash?: StringNullableWithAggregatesFilter<"blocks"> | string | null
    nonce?: StringNullableWithAggregatesFilter<"blocks"> | string | null
    logs_bloom?: StringNullableWithAggregatesFilter<"blocks"> | string | null
    transactions_root?: StringNullableWithAggregatesFilter<"blocks"> | string | null
    state_root?: StringNullableWithAggregatesFilter<"blocks"> | string | null
    receipts_root?: StringNullableWithAggregatesFilter<"blocks"> | string | null
    fee_recipient?: StringNullableWithAggregatesFilter<"blocks"> | string | null
    proposer_index?: BigIntNullableWithAggregatesFilter<"blocks"> | bigint | number | null
    gas_limit?: BigIntNullableWithAggregatesFilter<"blocks"> | bigint | number | null
    gas_used?: BigIntNullableWithAggregatesFilter<"blocks"> | bigint | number | null
    timestamp?: DateTimeNullableWithAggregatesFilter<"blocks"> | Date | string | null
    transaction_count?: BigIntNullableWithAggregatesFilter<"blocks"> | bigint | number | null
  }

  export type d_accountWhereInput = {
    AND?: d_accountWhereInput | d_accountWhereInput[]
    OR?: d_accountWhereInput[]
    NOT?: d_accountWhereInput | d_accountWhereInput[]
    account_id?: BigIntFilter<"d_account"> | bigint | number
    address?: StringFilter<"d_account"> | string
    eth_sent?: FloatNullableFilter<"d_account"> | number | null
    eth_received?: FloatNullableFilter<"d_account"> | number | null
    account_balance?: FloatNullableFilter<"d_account"> | number | null
  }

  export type d_accountOrderByWithRelationInput = {
    account_id?: SortOrder
    address?: SortOrder
    eth_sent?: SortOrderInput | SortOrder
    eth_received?: SortOrderInput | SortOrder
    account_balance?: SortOrderInput | SortOrder
  }

  export type d_accountWhereUniqueInput = Prisma.AtLeast<{
    address?: string
    AND?: d_accountWhereInput | d_accountWhereInput[]
    OR?: d_accountWhereInput[]
    NOT?: d_accountWhereInput | d_accountWhereInput[]
    account_id?: BigIntFilter<"d_account"> | bigint | number
    eth_sent?: FloatNullableFilter<"d_account"> | number | null
    eth_received?: FloatNullableFilter<"d_account"> | number | null
    account_balance?: FloatNullableFilter<"d_account"> | number | null
  }, "address">

  export type d_accountOrderByWithAggregationInput = {
    account_id?: SortOrder
    address?: SortOrder
    eth_sent?: SortOrderInput | SortOrder
    eth_received?: SortOrderInput | SortOrder
    account_balance?: SortOrderInput | SortOrder
    _count?: d_accountCountOrderByAggregateInput
    _avg?: d_accountAvgOrderByAggregateInput
    _max?: d_accountMaxOrderByAggregateInput
    _min?: d_accountMinOrderByAggregateInput
    _sum?: d_accountSumOrderByAggregateInput
  }

  export type d_accountScalarWhereWithAggregatesInput = {
    AND?: d_accountScalarWhereWithAggregatesInput | d_accountScalarWhereWithAggregatesInput[]
    OR?: d_accountScalarWhereWithAggregatesInput[]
    NOT?: d_accountScalarWhereWithAggregatesInput | d_accountScalarWhereWithAggregatesInput[]
    account_id?: BigIntWithAggregatesFilter<"d_account"> | bigint | number
    address?: StringWithAggregatesFilter<"d_account"> | string
    eth_sent?: FloatNullableWithAggregatesFilter<"d_account"> | number | null
    eth_received?: FloatNullableWithAggregatesFilter<"d_account"> | number | null
    account_balance?: FloatNullableWithAggregatesFilter<"d_account"> | number | null
  }

  export type d_blockWhereInput = {
    AND?: d_blockWhereInput | d_blockWhereInput[]
    OR?: d_blockWhereInput[]
    NOT?: d_blockWhereInput | d_blockWhereInput[]
    block_id?: BigIntFilter<"d_block"> | bigint | number
    timestamp?: DateTimeNullableFilter<"d_block"> | Date | string | null
    number?: BigIntNullableFilter<"d_block"> | bigint | number | null
    hash?: StringNullableFilter<"d_block"> | string | null
    parent_hash?: StringNullableFilter<"d_block"> | string | null
    fee_recipient?: StringNullableFilter<"d_block"> | string | null
    logs_bloom?: StringNullableFilter<"d_block"> | string | null
    transactions_root?: StringNullableFilter<"d_block"> | string | null
    state_root?: StringNullableFilter<"d_block"> | string | null
    proposer_index?: BigIntNullableFilter<"d_block"> | bigint | number | null
    gas_limit?: BigIntNullableFilter<"d_block"> | bigint | number | null
    gas_used?: BigIntNullableFilter<"d_block"> | bigint | number | null
    transaction_count?: BigIntNullableFilter<"d_block"> | bigint | number | null
  }

  export type d_blockOrderByWithRelationInput = {
    block_id?: SortOrder
    timestamp?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    parent_hash?: SortOrderInput | SortOrder
    fee_recipient?: SortOrderInput | SortOrder
    logs_bloom?: SortOrderInput | SortOrder
    transactions_root?: SortOrderInput | SortOrder
    state_root?: SortOrderInput | SortOrder
    proposer_index?: SortOrderInput | SortOrder
    gas_limit?: SortOrderInput | SortOrder
    gas_used?: SortOrderInput | SortOrder
    transaction_count?: SortOrderInput | SortOrder
  }

  export type d_blockWhereUniqueInput = Prisma.AtLeast<{
    block_id?: bigint | number
    AND?: d_blockWhereInput | d_blockWhereInput[]
    OR?: d_blockWhereInput[]
    NOT?: d_blockWhereInput | d_blockWhereInput[]
    timestamp?: DateTimeNullableFilter<"d_block"> | Date | string | null
    number?: BigIntNullableFilter<"d_block"> | bigint | number | null
    hash?: StringNullableFilter<"d_block"> | string | null
    parent_hash?: StringNullableFilter<"d_block"> | string | null
    fee_recipient?: StringNullableFilter<"d_block"> | string | null
    logs_bloom?: StringNullableFilter<"d_block"> | string | null
    transactions_root?: StringNullableFilter<"d_block"> | string | null
    state_root?: StringNullableFilter<"d_block"> | string | null
    proposer_index?: BigIntNullableFilter<"d_block"> | bigint | number | null
    gas_limit?: BigIntNullableFilter<"d_block"> | bigint | number | null
    gas_used?: BigIntNullableFilter<"d_block"> | bigint | number | null
    transaction_count?: BigIntNullableFilter<"d_block"> | bigint | number | null
  }, "block_id">

  export type d_blockOrderByWithAggregationInput = {
    block_id?: SortOrder
    timestamp?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    parent_hash?: SortOrderInput | SortOrder
    fee_recipient?: SortOrderInput | SortOrder
    logs_bloom?: SortOrderInput | SortOrder
    transactions_root?: SortOrderInput | SortOrder
    state_root?: SortOrderInput | SortOrder
    proposer_index?: SortOrderInput | SortOrder
    gas_limit?: SortOrderInput | SortOrder
    gas_used?: SortOrderInput | SortOrder
    transaction_count?: SortOrderInput | SortOrder
    _count?: d_blockCountOrderByAggregateInput
    _avg?: d_blockAvgOrderByAggregateInput
    _max?: d_blockMaxOrderByAggregateInput
    _min?: d_blockMinOrderByAggregateInput
    _sum?: d_blockSumOrderByAggregateInput
  }

  export type d_blockScalarWhereWithAggregatesInput = {
    AND?: d_blockScalarWhereWithAggregatesInput | d_blockScalarWhereWithAggregatesInput[]
    OR?: d_blockScalarWhereWithAggregatesInput[]
    NOT?: d_blockScalarWhereWithAggregatesInput | d_blockScalarWhereWithAggregatesInput[]
    block_id?: BigIntWithAggregatesFilter<"d_block"> | bigint | number
    timestamp?: DateTimeNullableWithAggregatesFilter<"d_block"> | Date | string | null
    number?: BigIntNullableWithAggregatesFilter<"d_block"> | bigint | number | null
    hash?: StringNullableWithAggregatesFilter<"d_block"> | string | null
    parent_hash?: StringNullableWithAggregatesFilter<"d_block"> | string | null
    fee_recipient?: StringNullableWithAggregatesFilter<"d_block"> | string | null
    logs_bloom?: StringNullableWithAggregatesFilter<"d_block"> | string | null
    transactions_root?: StringNullableWithAggregatesFilter<"d_block"> | string | null
    state_root?: StringNullableWithAggregatesFilter<"d_block"> | string | null
    proposer_index?: BigIntNullableWithAggregatesFilter<"d_block"> | bigint | number | null
    gas_limit?: BigIntNullableWithAggregatesFilter<"d_block"> | bigint | number | null
    gas_used?: BigIntNullableWithAggregatesFilter<"d_block"> | bigint | number | null
    transaction_count?: BigIntNullableWithAggregatesFilter<"d_block"> | bigint | number | null
  }

  export type d_dateWhereInput = {
    AND?: d_dateWhereInput | d_dateWhereInput[]
    OR?: d_dateWhereInput[]
    NOT?: d_dateWhereInput | d_dateWhereInput[]
    date?: DateTimeFilter<"d_date"> | Date | string
    year?: IntNullableFilter<"d_date"> | number | null
    month?: IntNullableFilter<"d_date"> | number | null
    day?: IntNullableFilter<"d_date"> | number | null
    weekday?: IntNullableFilter<"d_date"> | number | null
    day_in_chars?: StringNullableFilter<"d_date"> | string | null
    week?: IntNullableFilter<"d_date"> | number | null
  }

  export type d_dateOrderByWithRelationInput = {
    date?: SortOrder
    year?: SortOrderInput | SortOrder
    month?: SortOrderInput | SortOrder
    day?: SortOrderInput | SortOrder
    weekday?: SortOrderInput | SortOrder
    day_in_chars?: SortOrderInput | SortOrder
    week?: SortOrderInput | SortOrder
  }

  export type d_dateWhereUniqueInput = Prisma.AtLeast<{
    date?: Date | string
    AND?: d_dateWhereInput | d_dateWhereInput[]
    OR?: d_dateWhereInput[]
    NOT?: d_dateWhereInput | d_dateWhereInput[]
    year?: IntNullableFilter<"d_date"> | number | null
    month?: IntNullableFilter<"d_date"> | number | null
    day?: IntNullableFilter<"d_date"> | number | null
    weekday?: IntNullableFilter<"d_date"> | number | null
    day_in_chars?: StringNullableFilter<"d_date"> | string | null
    week?: IntNullableFilter<"d_date"> | number | null
  }, "date">

  export type d_dateOrderByWithAggregationInput = {
    date?: SortOrder
    year?: SortOrderInput | SortOrder
    month?: SortOrderInput | SortOrder
    day?: SortOrderInput | SortOrder
    weekday?: SortOrderInput | SortOrder
    day_in_chars?: SortOrderInput | SortOrder
    week?: SortOrderInput | SortOrder
    _count?: d_dateCountOrderByAggregateInput
    _avg?: d_dateAvgOrderByAggregateInput
    _max?: d_dateMaxOrderByAggregateInput
    _min?: d_dateMinOrderByAggregateInput
    _sum?: d_dateSumOrderByAggregateInput
  }

  export type d_dateScalarWhereWithAggregatesInput = {
    AND?: d_dateScalarWhereWithAggregatesInput | d_dateScalarWhereWithAggregatesInput[]
    OR?: d_dateScalarWhereWithAggregatesInput[]
    NOT?: d_dateScalarWhereWithAggregatesInput | d_dateScalarWhereWithAggregatesInput[]
    date?: DateTimeWithAggregatesFilter<"d_date"> | Date | string
    year?: IntNullableWithAggregatesFilter<"d_date"> | number | null
    month?: IntNullableWithAggregatesFilter<"d_date"> | number | null
    day?: IntNullableWithAggregatesFilter<"d_date"> | number | null
    weekday?: IntNullableWithAggregatesFilter<"d_date"> | number | null
    day_in_chars?: StringNullableWithAggregatesFilter<"d_date"> | string | null
    week?: IntNullableWithAggregatesFilter<"d_date"> | number | null
  }

  export type d_timeWhereInput = {
    AND?: d_timeWhereInput | d_timeWhereInput[]
    OR?: d_timeWhereInput[]
    NOT?: d_timeWhereInput | d_timeWhereInput[]
    time?: DateTimeFilter<"d_time"> | Date | string
    hours?: IntNullableFilter<"d_time"> | number | null
    minutes?: IntNullableFilter<"d_time"> | number | null
    seconds?: IntNullableFilter<"d_time"> | number | null
  }

  export type d_timeOrderByWithRelationInput = {
    time?: SortOrder
    hours?: SortOrderInput | SortOrder
    minutes?: SortOrderInput | SortOrder
    seconds?: SortOrderInput | SortOrder
  }

  export type d_timeWhereUniqueInput = Prisma.AtLeast<{
    time?: Date | string
    AND?: d_timeWhereInput | d_timeWhereInput[]
    OR?: d_timeWhereInput[]
    NOT?: d_timeWhereInput | d_timeWhereInput[]
    hours?: IntNullableFilter<"d_time"> | number | null
    minutes?: IntNullableFilter<"d_time"> | number | null
    seconds?: IntNullableFilter<"d_time"> | number | null
  }, "time">

  export type d_timeOrderByWithAggregationInput = {
    time?: SortOrder
    hours?: SortOrderInput | SortOrder
    minutes?: SortOrderInput | SortOrder
    seconds?: SortOrderInput | SortOrder
    _count?: d_timeCountOrderByAggregateInput
    _avg?: d_timeAvgOrderByAggregateInput
    _max?: d_timeMaxOrderByAggregateInput
    _min?: d_timeMinOrderByAggregateInput
    _sum?: d_timeSumOrderByAggregateInput
  }

  export type d_timeScalarWhereWithAggregatesInput = {
    AND?: d_timeScalarWhereWithAggregatesInput | d_timeScalarWhereWithAggregatesInput[]
    OR?: d_timeScalarWhereWithAggregatesInput[]
    NOT?: d_timeScalarWhereWithAggregatesInput | d_timeScalarWhereWithAggregatesInput[]
    time?: DateTimeWithAggregatesFilter<"d_time"> | Date | string
    hours?: IntNullableWithAggregatesFilter<"d_time"> | number | null
    minutes?: IntNullableWithAggregatesFilter<"d_time"> | number | null
    seconds?: IntNullableWithAggregatesFilter<"d_time"> | number | null
  }

  export type d_transactionWhereInput = {
    AND?: d_transactionWhereInput | d_transactionWhereInput[]
    OR?: d_transactionWhereInput[]
    NOT?: d_transactionWhereInput | d_transactionWhereInput[]
    transaction_id?: BigIntFilter<"d_transaction"> | bigint | number
    hash?: StringNullableFilter<"d_transaction"> | string | null
    nonce?: BigIntNullableFilter<"d_transaction"> | bigint | number | null
    transaction_index?: BigIntNullableFilter<"d_transaction"> | bigint | number | null
    from_address?: StringNullableFilter<"d_transaction"> | string | null
    to_address?: StringNullableFilter<"d_transaction"> | string | null
    value?: DecimalNullableFilter<"d_transaction"> | Decimal | DecimalJsLike | number | string | null
    gas?: BigIntNullableFilter<"d_transaction"> | bigint | number | null
    gas_price?: BigIntNullableFilter<"d_transaction"> | bigint | number | null
    input?: StringNullableFilter<"d_transaction"> | string | null
    receipt_cumulative_gas_used?: BigIntNullableFilter<"d_transaction"> | bigint | number | null
    receipt_gas_used?: BigIntNullableFilter<"d_transaction"> | bigint | number | null
    receipt_contract_address?: StringNullableFilter<"d_transaction"> | string | null
    receipt_status?: BigIntNullableFilter<"d_transaction"> | bigint | number | null
    block_timestamp?: DateTimeNullableFilter<"d_transaction"> | Date | string | null
    block_number?: BigIntNullableFilter<"d_transaction"> | bigint | number | null
    block_hash?: StringNullableFilter<"d_transaction"> | string | null
    emission_by_transaction?: FloatNullableFilter<"d_transaction"> | number | null
    emission_by_balance?: FloatNullableFilter<"d_transaction"> | number | null
  }

  export type d_transactionOrderByWithRelationInput = {
    transaction_id?: SortOrder
    hash?: SortOrderInput | SortOrder
    nonce?: SortOrderInput | SortOrder
    transaction_index?: SortOrderInput | SortOrder
    from_address?: SortOrderInput | SortOrder
    to_address?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    gas?: SortOrderInput | SortOrder
    gas_price?: SortOrderInput | SortOrder
    input?: SortOrderInput | SortOrder
    receipt_cumulative_gas_used?: SortOrderInput | SortOrder
    receipt_gas_used?: SortOrderInput | SortOrder
    receipt_contract_address?: SortOrderInput | SortOrder
    receipt_status?: SortOrderInput | SortOrder
    block_timestamp?: SortOrderInput | SortOrder
    block_number?: SortOrderInput | SortOrder
    block_hash?: SortOrderInput | SortOrder
    emission_by_transaction?: SortOrderInput | SortOrder
    emission_by_balance?: SortOrderInput | SortOrder
  }

  export type d_transactionWhereUniqueInput = Prisma.AtLeast<{
    transaction_id?: bigint | number
    AND?: d_transactionWhereInput | d_transactionWhereInput[]
    OR?: d_transactionWhereInput[]
    NOT?: d_transactionWhereInput | d_transactionWhereInput[]
    hash?: StringNullableFilter<"d_transaction"> | string | null
    nonce?: BigIntNullableFilter<"d_transaction"> | bigint | number | null
    transaction_index?: BigIntNullableFilter<"d_transaction"> | bigint | number | null
    from_address?: StringNullableFilter<"d_transaction"> | string | null
    to_address?: StringNullableFilter<"d_transaction"> | string | null
    value?: DecimalNullableFilter<"d_transaction"> | Decimal | DecimalJsLike | number | string | null
    gas?: BigIntNullableFilter<"d_transaction"> | bigint | number | null
    gas_price?: BigIntNullableFilter<"d_transaction"> | bigint | number | null
    input?: StringNullableFilter<"d_transaction"> | string | null
    receipt_cumulative_gas_used?: BigIntNullableFilter<"d_transaction"> | bigint | number | null
    receipt_gas_used?: BigIntNullableFilter<"d_transaction"> | bigint | number | null
    receipt_contract_address?: StringNullableFilter<"d_transaction"> | string | null
    receipt_status?: BigIntNullableFilter<"d_transaction"> | bigint | number | null
    block_timestamp?: DateTimeNullableFilter<"d_transaction"> | Date | string | null
    block_number?: BigIntNullableFilter<"d_transaction"> | bigint | number | null
    block_hash?: StringNullableFilter<"d_transaction"> | string | null
    emission_by_transaction?: FloatNullableFilter<"d_transaction"> | number | null
    emission_by_balance?: FloatNullableFilter<"d_transaction"> | number | null
  }, "transaction_id">

  export type d_transactionOrderByWithAggregationInput = {
    transaction_id?: SortOrder
    hash?: SortOrderInput | SortOrder
    nonce?: SortOrderInput | SortOrder
    transaction_index?: SortOrderInput | SortOrder
    from_address?: SortOrderInput | SortOrder
    to_address?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    gas?: SortOrderInput | SortOrder
    gas_price?: SortOrderInput | SortOrder
    input?: SortOrderInput | SortOrder
    receipt_cumulative_gas_used?: SortOrderInput | SortOrder
    receipt_gas_used?: SortOrderInput | SortOrder
    receipt_contract_address?: SortOrderInput | SortOrder
    receipt_status?: SortOrderInput | SortOrder
    block_timestamp?: SortOrderInput | SortOrder
    block_number?: SortOrderInput | SortOrder
    block_hash?: SortOrderInput | SortOrder
    emission_by_transaction?: SortOrderInput | SortOrder
    emission_by_balance?: SortOrderInput | SortOrder
    _count?: d_transactionCountOrderByAggregateInput
    _avg?: d_transactionAvgOrderByAggregateInput
    _max?: d_transactionMaxOrderByAggregateInput
    _min?: d_transactionMinOrderByAggregateInput
    _sum?: d_transactionSumOrderByAggregateInput
  }

  export type d_transactionScalarWhereWithAggregatesInput = {
    AND?: d_transactionScalarWhereWithAggregatesInput | d_transactionScalarWhereWithAggregatesInput[]
    OR?: d_transactionScalarWhereWithAggregatesInput[]
    NOT?: d_transactionScalarWhereWithAggregatesInput | d_transactionScalarWhereWithAggregatesInput[]
    transaction_id?: BigIntWithAggregatesFilter<"d_transaction"> | bigint | number
    hash?: StringNullableWithAggregatesFilter<"d_transaction"> | string | null
    nonce?: BigIntNullableWithAggregatesFilter<"d_transaction"> | bigint | number | null
    transaction_index?: BigIntNullableWithAggregatesFilter<"d_transaction"> | bigint | number | null
    from_address?: StringNullableWithAggregatesFilter<"d_transaction"> | string | null
    to_address?: StringNullableWithAggregatesFilter<"d_transaction"> | string | null
    value?: DecimalNullableWithAggregatesFilter<"d_transaction"> | Decimal | DecimalJsLike | number | string | null
    gas?: BigIntNullableWithAggregatesFilter<"d_transaction"> | bigint | number | null
    gas_price?: BigIntNullableWithAggregatesFilter<"d_transaction"> | bigint | number | null
    input?: StringNullableWithAggregatesFilter<"d_transaction"> | string | null
    receipt_cumulative_gas_used?: BigIntNullableWithAggregatesFilter<"d_transaction"> | bigint | number | null
    receipt_gas_used?: BigIntNullableWithAggregatesFilter<"d_transaction"> | bigint | number | null
    receipt_contract_address?: StringNullableWithAggregatesFilter<"d_transaction"> | string | null
    receipt_status?: BigIntNullableWithAggregatesFilter<"d_transaction"> | bigint | number | null
    block_timestamp?: DateTimeNullableWithAggregatesFilter<"d_transaction"> | Date | string | null
    block_number?: BigIntNullableWithAggregatesFilter<"d_transaction"> | bigint | number | null
    block_hash?: StringNullableWithAggregatesFilter<"d_transaction"> | string | null
    emission_by_transaction?: FloatNullableWithAggregatesFilter<"d_transaction"> | number | null
    emission_by_balance?: FloatNullableWithAggregatesFilter<"d_transaction"> | number | null
  }

  export type token_transfersWhereInput = {
    AND?: token_transfersWhereInput | token_transfersWhereInput[]
    OR?: token_transfersWhereInput[]
    NOT?: token_transfersWhereInput | token_transfersWhereInput[]
    token_address?: StringNullableFilter<"token_transfers"> | string | null
    from_address?: StringNullableFilter<"token_transfers"> | string | null
    to_address?: StringNullableFilter<"token_transfers"> | string | null
    value?: DecimalNullableFilter<"token_transfers"> | Decimal | DecimalJsLike | number | string | null
    transaction_hash?: StringFilter<"token_transfers"> | string
    log_index?: BigIntFilter<"token_transfers"> | bigint | number
    block_timestamp?: DateTimeNullableFilter<"token_transfers"> | Date | string | null
    block_number?: BigIntNullableFilter<"token_transfers"> | bigint | number | null
    block_hash?: StringNullableFilter<"token_transfers"> | string | null
  }

  export type token_transfersOrderByWithRelationInput = {
    token_address?: SortOrderInput | SortOrder
    from_address?: SortOrderInput | SortOrder
    to_address?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    transaction_hash?: SortOrder
    log_index?: SortOrder
    block_timestamp?: SortOrderInput | SortOrder
    block_number?: SortOrderInput | SortOrder
    block_hash?: SortOrderInput | SortOrder
  }

  export type token_transfersWhereUniqueInput = Prisma.AtLeast<{
    transaction_hash_log_index?: token_transfersTransaction_hashLog_indexCompoundUniqueInput
    AND?: token_transfersWhereInput | token_transfersWhereInput[]
    OR?: token_transfersWhereInput[]
    NOT?: token_transfersWhereInput | token_transfersWhereInput[]
    token_address?: StringNullableFilter<"token_transfers"> | string | null
    from_address?: StringNullableFilter<"token_transfers"> | string | null
    to_address?: StringNullableFilter<"token_transfers"> | string | null
    value?: DecimalNullableFilter<"token_transfers"> | Decimal | DecimalJsLike | number | string | null
    transaction_hash?: StringFilter<"token_transfers"> | string
    log_index?: BigIntFilter<"token_transfers"> | bigint | number
    block_timestamp?: DateTimeNullableFilter<"token_transfers"> | Date | string | null
    block_number?: BigIntNullableFilter<"token_transfers"> | bigint | number | null
    block_hash?: StringNullableFilter<"token_transfers"> | string | null
  }, "transaction_hash_log_index">

  export type token_transfersOrderByWithAggregationInput = {
    token_address?: SortOrderInput | SortOrder
    from_address?: SortOrderInput | SortOrder
    to_address?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    transaction_hash?: SortOrder
    log_index?: SortOrder
    block_timestamp?: SortOrderInput | SortOrder
    block_number?: SortOrderInput | SortOrder
    block_hash?: SortOrderInput | SortOrder
    _count?: token_transfersCountOrderByAggregateInput
    _avg?: token_transfersAvgOrderByAggregateInput
    _max?: token_transfersMaxOrderByAggregateInput
    _min?: token_transfersMinOrderByAggregateInput
    _sum?: token_transfersSumOrderByAggregateInput
  }

  export type token_transfersScalarWhereWithAggregatesInput = {
    AND?: token_transfersScalarWhereWithAggregatesInput | token_transfersScalarWhereWithAggregatesInput[]
    OR?: token_transfersScalarWhereWithAggregatesInput[]
    NOT?: token_transfersScalarWhereWithAggregatesInput | token_transfersScalarWhereWithAggregatesInput[]
    token_address?: StringNullableWithAggregatesFilter<"token_transfers"> | string | null
    from_address?: StringNullableWithAggregatesFilter<"token_transfers"> | string | null
    to_address?: StringNullableWithAggregatesFilter<"token_transfers"> | string | null
    value?: DecimalNullableWithAggregatesFilter<"token_transfers"> | Decimal | DecimalJsLike | number | string | null
    transaction_hash?: StringWithAggregatesFilter<"token_transfers"> | string
    log_index?: BigIntWithAggregatesFilter<"token_transfers"> | bigint | number
    block_timestamp?: DateTimeNullableWithAggregatesFilter<"token_transfers"> | Date | string | null
    block_number?: BigIntNullableWithAggregatesFilter<"token_transfers"> | bigint | number | null
    block_hash?: StringNullableWithAggregatesFilter<"token_transfers"> | string | null
  }

  export type transactionsWhereInput = {
    AND?: transactionsWhereInput | transactionsWhereInput[]
    OR?: transactionsWhereInput[]
    NOT?: transactionsWhereInput | transactionsWhereInput[]
    hash?: StringFilter<"transactions"> | string
    nonce?: BigIntNullableFilter<"transactions"> | bigint | number | null
    transaction_index?: BigIntNullableFilter<"transactions"> | bigint | number | null
    from_address?: StringNullableFilter<"transactions"> | string | null
    to_address?: StringNullableFilter<"transactions"> | string | null
    value?: DecimalNullableFilter<"transactions"> | Decimal | DecimalJsLike | number | string | null
    gas?: BigIntNullableFilter<"transactions"> | bigint | number | null
    gas_price?: BigIntNullableFilter<"transactions"> | bigint | number | null
    input?: StringNullableFilter<"transactions"> | string | null
    receipt_cumulative_gas_used?: BigIntNullableFilter<"transactions"> | bigint | number | null
    receipt_gas_used?: BigIntNullableFilter<"transactions"> | bigint | number | null
    receipt_contract_address?: StringNullableFilter<"transactions"> | string | null
    receipt_root?: StringNullableFilter<"transactions"> | string | null
    receipt_status?: BigIntNullableFilter<"transactions"> | bigint | number | null
    block_timestamp?: DateTimeNullableFilter<"transactions"> | Date | string | null
    block_number?: BigIntNullableFilter<"transactions"> | bigint | number | null
    block_hash?: StringNullableFilter<"transactions"> | string | null
    emission_by_transaction?: FloatNullableFilter<"transactions"> | number | null
    emission_by_balance?: FloatNullableFilter<"transactions"> | number | null
  }

  export type transactionsOrderByWithRelationInput = {
    hash?: SortOrder
    nonce?: SortOrderInput | SortOrder
    transaction_index?: SortOrderInput | SortOrder
    from_address?: SortOrderInput | SortOrder
    to_address?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    gas?: SortOrderInput | SortOrder
    gas_price?: SortOrderInput | SortOrder
    input?: SortOrderInput | SortOrder
    receipt_cumulative_gas_used?: SortOrderInput | SortOrder
    receipt_gas_used?: SortOrderInput | SortOrder
    receipt_contract_address?: SortOrderInput | SortOrder
    receipt_root?: SortOrderInput | SortOrder
    receipt_status?: SortOrderInput | SortOrder
    block_timestamp?: SortOrderInput | SortOrder
    block_number?: SortOrderInput | SortOrder
    block_hash?: SortOrderInput | SortOrder
    emission_by_transaction?: SortOrderInput | SortOrder
    emission_by_balance?: SortOrderInput | SortOrder
  }

  export type transactionsWhereUniqueInput = Prisma.AtLeast<{
    hash?: string
    AND?: transactionsWhereInput | transactionsWhereInput[]
    OR?: transactionsWhereInput[]
    NOT?: transactionsWhereInput | transactionsWhereInput[]
    nonce?: BigIntNullableFilter<"transactions"> | bigint | number | null
    transaction_index?: BigIntNullableFilter<"transactions"> | bigint | number | null
    from_address?: StringNullableFilter<"transactions"> | string | null
    to_address?: StringNullableFilter<"transactions"> | string | null
    value?: DecimalNullableFilter<"transactions"> | Decimal | DecimalJsLike | number | string | null
    gas?: BigIntNullableFilter<"transactions"> | bigint | number | null
    gas_price?: BigIntNullableFilter<"transactions"> | bigint | number | null
    input?: StringNullableFilter<"transactions"> | string | null
    receipt_cumulative_gas_used?: BigIntNullableFilter<"transactions"> | bigint | number | null
    receipt_gas_used?: BigIntNullableFilter<"transactions"> | bigint | number | null
    receipt_contract_address?: StringNullableFilter<"transactions"> | string | null
    receipt_root?: StringNullableFilter<"transactions"> | string | null
    receipt_status?: BigIntNullableFilter<"transactions"> | bigint | number | null
    block_timestamp?: DateTimeNullableFilter<"transactions"> | Date | string | null
    block_number?: BigIntNullableFilter<"transactions"> | bigint | number | null
    block_hash?: StringNullableFilter<"transactions"> | string | null
    emission_by_transaction?: FloatNullableFilter<"transactions"> | number | null
    emission_by_balance?: FloatNullableFilter<"transactions"> | number | null
  }, "hash">

  export type transactionsOrderByWithAggregationInput = {
    hash?: SortOrder
    nonce?: SortOrderInput | SortOrder
    transaction_index?: SortOrderInput | SortOrder
    from_address?: SortOrderInput | SortOrder
    to_address?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    gas?: SortOrderInput | SortOrder
    gas_price?: SortOrderInput | SortOrder
    input?: SortOrderInput | SortOrder
    receipt_cumulative_gas_used?: SortOrderInput | SortOrder
    receipt_gas_used?: SortOrderInput | SortOrder
    receipt_contract_address?: SortOrderInput | SortOrder
    receipt_root?: SortOrderInput | SortOrder
    receipt_status?: SortOrderInput | SortOrder
    block_timestamp?: SortOrderInput | SortOrder
    block_number?: SortOrderInput | SortOrder
    block_hash?: SortOrderInput | SortOrder
    emission_by_transaction?: SortOrderInput | SortOrder
    emission_by_balance?: SortOrderInput | SortOrder
    _count?: transactionsCountOrderByAggregateInput
    _avg?: transactionsAvgOrderByAggregateInput
    _max?: transactionsMaxOrderByAggregateInput
    _min?: transactionsMinOrderByAggregateInput
    _sum?: transactionsSumOrderByAggregateInput
  }

  export type transactionsScalarWhereWithAggregatesInput = {
    AND?: transactionsScalarWhereWithAggregatesInput | transactionsScalarWhereWithAggregatesInput[]
    OR?: transactionsScalarWhereWithAggregatesInput[]
    NOT?: transactionsScalarWhereWithAggregatesInput | transactionsScalarWhereWithAggregatesInput[]
    hash?: StringWithAggregatesFilter<"transactions"> | string
    nonce?: BigIntNullableWithAggregatesFilter<"transactions"> | bigint | number | null
    transaction_index?: BigIntNullableWithAggregatesFilter<"transactions"> | bigint | number | null
    from_address?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    to_address?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    value?: DecimalNullableWithAggregatesFilter<"transactions"> | Decimal | DecimalJsLike | number | string | null
    gas?: BigIntNullableWithAggregatesFilter<"transactions"> | bigint | number | null
    gas_price?: BigIntNullableWithAggregatesFilter<"transactions"> | bigint | number | null
    input?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    receipt_cumulative_gas_used?: BigIntNullableWithAggregatesFilter<"transactions"> | bigint | number | null
    receipt_gas_used?: BigIntNullableWithAggregatesFilter<"transactions"> | bigint | number | null
    receipt_contract_address?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    receipt_root?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    receipt_status?: BigIntNullableWithAggregatesFilter<"transactions"> | bigint | number | null
    block_timestamp?: DateTimeNullableWithAggregatesFilter<"transactions"> | Date | string | null
    block_number?: BigIntNullableWithAggregatesFilter<"transactions"> | bigint | number | null
    block_hash?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    emission_by_transaction?: FloatNullableWithAggregatesFilter<"transactions"> | number | null
    emission_by_balance?: FloatNullableWithAggregatesFilter<"transactions"> | number | null
  }

  export type blocksCreateInput = {
    number?: bigint | number | null
    hash: string
    parent_hash?: string | null
    nonce?: string | null
    logs_bloom?: string | null
    transactions_root?: string | null
    state_root?: string | null
    receipts_root?: string | null
    fee_recipient?: string | null
    proposer_index?: bigint | number | null
    gas_limit?: bigint | number | null
    gas_used?: bigint | number | null
    timestamp?: Date | string | null
    transaction_count?: bigint | number | null
  }

  export type blocksUncheckedCreateInput = {
    number?: bigint | number | null
    hash: string
    parent_hash?: string | null
    nonce?: string | null
    logs_bloom?: string | null
    transactions_root?: string | null
    state_root?: string | null
    receipts_root?: string | null
    fee_recipient?: string | null
    proposer_index?: bigint | number | null
    gas_limit?: bigint | number | null
    gas_used?: bigint | number | null
    timestamp?: Date | string | null
    transaction_count?: bigint | number | null
  }

  export type blocksUpdateInput = {
    number?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    hash?: StringFieldUpdateOperationsInput | string
    parent_hash?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableStringFieldUpdateOperationsInput | string | null
    logs_bloom?: NullableStringFieldUpdateOperationsInput | string | null
    transactions_root?: NullableStringFieldUpdateOperationsInput | string | null
    state_root?: NullableStringFieldUpdateOperationsInput | string | null
    receipts_root?: NullableStringFieldUpdateOperationsInput | string | null
    fee_recipient?: NullableStringFieldUpdateOperationsInput | string | null
    proposer_index?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_limit?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type blocksUncheckedUpdateInput = {
    number?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    hash?: StringFieldUpdateOperationsInput | string
    parent_hash?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableStringFieldUpdateOperationsInput | string | null
    logs_bloom?: NullableStringFieldUpdateOperationsInput | string | null
    transactions_root?: NullableStringFieldUpdateOperationsInput | string | null
    state_root?: NullableStringFieldUpdateOperationsInput | string | null
    receipts_root?: NullableStringFieldUpdateOperationsInput | string | null
    fee_recipient?: NullableStringFieldUpdateOperationsInput | string | null
    proposer_index?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_limit?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type blocksCreateManyInput = {
    number?: bigint | number | null
    hash: string
    parent_hash?: string | null
    nonce?: string | null
    logs_bloom?: string | null
    transactions_root?: string | null
    state_root?: string | null
    receipts_root?: string | null
    fee_recipient?: string | null
    proposer_index?: bigint | number | null
    gas_limit?: bigint | number | null
    gas_used?: bigint | number | null
    timestamp?: Date | string | null
    transaction_count?: bigint | number | null
  }

  export type blocksUpdateManyMutationInput = {
    number?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    hash?: StringFieldUpdateOperationsInput | string
    parent_hash?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableStringFieldUpdateOperationsInput | string | null
    logs_bloom?: NullableStringFieldUpdateOperationsInput | string | null
    transactions_root?: NullableStringFieldUpdateOperationsInput | string | null
    state_root?: NullableStringFieldUpdateOperationsInput | string | null
    receipts_root?: NullableStringFieldUpdateOperationsInput | string | null
    fee_recipient?: NullableStringFieldUpdateOperationsInput | string | null
    proposer_index?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_limit?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type blocksUncheckedUpdateManyInput = {
    number?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    hash?: StringFieldUpdateOperationsInput | string
    parent_hash?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableStringFieldUpdateOperationsInput | string | null
    logs_bloom?: NullableStringFieldUpdateOperationsInput | string | null
    transactions_root?: NullableStringFieldUpdateOperationsInput | string | null
    state_root?: NullableStringFieldUpdateOperationsInput | string | null
    receipts_root?: NullableStringFieldUpdateOperationsInput | string | null
    fee_recipient?: NullableStringFieldUpdateOperationsInput | string | null
    proposer_index?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_limit?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type d_accountCreateInput = {
    account_id?: bigint | number
    address: string
    eth_sent?: number | null
    eth_received?: number | null
    account_balance?: number | null
  }

  export type d_accountUncheckedCreateInput = {
    account_id?: bigint | number
    address: string
    eth_sent?: number | null
    eth_received?: number | null
    account_balance?: number | null
  }

  export type d_accountUpdateInput = {
    account_id?: BigIntFieldUpdateOperationsInput | bigint | number
    address?: StringFieldUpdateOperationsInput | string
    eth_sent?: NullableFloatFieldUpdateOperationsInput | number | null
    eth_received?: NullableFloatFieldUpdateOperationsInput | number | null
    account_balance?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type d_accountUncheckedUpdateInput = {
    account_id?: BigIntFieldUpdateOperationsInput | bigint | number
    address?: StringFieldUpdateOperationsInput | string
    eth_sent?: NullableFloatFieldUpdateOperationsInput | number | null
    eth_received?: NullableFloatFieldUpdateOperationsInput | number | null
    account_balance?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type d_accountCreateManyInput = {
    account_id?: bigint | number
    address: string
    eth_sent?: number | null
    eth_received?: number | null
    account_balance?: number | null
  }

  export type d_accountUpdateManyMutationInput = {
    account_id?: BigIntFieldUpdateOperationsInput | bigint | number
    address?: StringFieldUpdateOperationsInput | string
    eth_sent?: NullableFloatFieldUpdateOperationsInput | number | null
    eth_received?: NullableFloatFieldUpdateOperationsInput | number | null
    account_balance?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type d_accountUncheckedUpdateManyInput = {
    account_id?: BigIntFieldUpdateOperationsInput | bigint | number
    address?: StringFieldUpdateOperationsInput | string
    eth_sent?: NullableFloatFieldUpdateOperationsInput | number | null
    eth_received?: NullableFloatFieldUpdateOperationsInput | number | null
    account_balance?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type d_blockCreateInput = {
    block_id?: bigint | number
    timestamp?: Date | string | null
    number?: bigint | number | null
    hash?: string | null
    parent_hash?: string | null
    fee_recipient?: string | null
    logs_bloom?: string | null
    transactions_root?: string | null
    state_root?: string | null
    proposer_index?: bigint | number | null
    gas_limit?: bigint | number | null
    gas_used?: bigint | number | null
    transaction_count?: bigint | number | null
  }

  export type d_blockUncheckedCreateInput = {
    block_id?: bigint | number
    timestamp?: Date | string | null
    number?: bigint | number | null
    hash?: string | null
    parent_hash?: string | null
    fee_recipient?: string | null
    logs_bloom?: string | null
    transactions_root?: string | null
    state_root?: string | null
    proposer_index?: bigint | number | null
    gas_limit?: bigint | number | null
    gas_used?: bigint | number | null
    transaction_count?: bigint | number | null
  }

  export type d_blockUpdateInput = {
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    number?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    parent_hash?: NullableStringFieldUpdateOperationsInput | string | null
    fee_recipient?: NullableStringFieldUpdateOperationsInput | string | null
    logs_bloom?: NullableStringFieldUpdateOperationsInput | string | null
    transactions_root?: NullableStringFieldUpdateOperationsInput | string | null
    state_root?: NullableStringFieldUpdateOperationsInput | string | null
    proposer_index?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_limit?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transaction_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type d_blockUncheckedUpdateInput = {
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    number?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    parent_hash?: NullableStringFieldUpdateOperationsInput | string | null
    fee_recipient?: NullableStringFieldUpdateOperationsInput | string | null
    logs_bloom?: NullableStringFieldUpdateOperationsInput | string | null
    transactions_root?: NullableStringFieldUpdateOperationsInput | string | null
    state_root?: NullableStringFieldUpdateOperationsInput | string | null
    proposer_index?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_limit?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transaction_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type d_blockCreateManyInput = {
    block_id?: bigint | number
    timestamp?: Date | string | null
    number?: bigint | number | null
    hash?: string | null
    parent_hash?: string | null
    fee_recipient?: string | null
    logs_bloom?: string | null
    transactions_root?: string | null
    state_root?: string | null
    proposer_index?: bigint | number | null
    gas_limit?: bigint | number | null
    gas_used?: bigint | number | null
    transaction_count?: bigint | number | null
  }

  export type d_blockUpdateManyMutationInput = {
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    number?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    parent_hash?: NullableStringFieldUpdateOperationsInput | string | null
    fee_recipient?: NullableStringFieldUpdateOperationsInput | string | null
    logs_bloom?: NullableStringFieldUpdateOperationsInput | string | null
    transactions_root?: NullableStringFieldUpdateOperationsInput | string | null
    state_root?: NullableStringFieldUpdateOperationsInput | string | null
    proposer_index?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_limit?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transaction_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type d_blockUncheckedUpdateManyInput = {
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    number?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    parent_hash?: NullableStringFieldUpdateOperationsInput | string | null
    fee_recipient?: NullableStringFieldUpdateOperationsInput | string | null
    logs_bloom?: NullableStringFieldUpdateOperationsInput | string | null
    transactions_root?: NullableStringFieldUpdateOperationsInput | string | null
    state_root?: NullableStringFieldUpdateOperationsInput | string | null
    proposer_index?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_limit?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transaction_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type d_dateCreateInput = {
    date: Date | string
    year?: number | null
    month?: number | null
    day?: number | null
    weekday?: number | null
    day_in_chars?: string | null
    week?: number | null
  }

  export type d_dateUncheckedCreateInput = {
    date: Date | string
    year?: number | null
    month?: number | null
    day?: number | null
    weekday?: number | null
    day_in_chars?: string | null
    week?: number | null
  }

  export type d_dateUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableIntFieldUpdateOperationsInput | number | null
    weekday?: NullableIntFieldUpdateOperationsInput | number | null
    day_in_chars?: NullableStringFieldUpdateOperationsInput | string | null
    week?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type d_dateUncheckedUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableIntFieldUpdateOperationsInput | number | null
    weekday?: NullableIntFieldUpdateOperationsInput | number | null
    day_in_chars?: NullableStringFieldUpdateOperationsInput | string | null
    week?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type d_dateCreateManyInput = {
    date: Date | string
    year?: number | null
    month?: number | null
    day?: number | null
    weekday?: number | null
    day_in_chars?: string | null
    week?: number | null
  }

  export type d_dateUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableIntFieldUpdateOperationsInput | number | null
    weekday?: NullableIntFieldUpdateOperationsInput | number | null
    day_in_chars?: NullableStringFieldUpdateOperationsInput | string | null
    week?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type d_dateUncheckedUpdateManyInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableIntFieldUpdateOperationsInput | number | null
    weekday?: NullableIntFieldUpdateOperationsInput | number | null
    day_in_chars?: NullableStringFieldUpdateOperationsInput | string | null
    week?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type d_timeCreateInput = {
    time: Date | string
    hours?: number | null
    minutes?: number | null
    seconds?: number | null
  }

  export type d_timeUncheckedCreateInput = {
    time: Date | string
    hours?: number | null
    minutes?: number | null
    seconds?: number | null
  }

  export type d_timeUpdateInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    minutes?: NullableIntFieldUpdateOperationsInput | number | null
    seconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type d_timeUncheckedUpdateInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    minutes?: NullableIntFieldUpdateOperationsInput | number | null
    seconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type d_timeCreateManyInput = {
    time: Date | string
    hours?: number | null
    minutes?: number | null
    seconds?: number | null
  }

  export type d_timeUpdateManyMutationInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    minutes?: NullableIntFieldUpdateOperationsInput | number | null
    seconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type d_timeUncheckedUpdateManyInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    minutes?: NullableIntFieldUpdateOperationsInput | number | null
    seconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type d_transactionCreateInput = {
    transaction_id?: bigint | number
    hash?: string | null
    nonce?: bigint | number | null
    transaction_index?: bigint | number | null
    from_address?: string | null
    to_address?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    gas?: bigint | number | null
    gas_price?: bigint | number | null
    input?: string | null
    receipt_cumulative_gas_used?: bigint | number | null
    receipt_gas_used?: bigint | number | null
    receipt_contract_address?: string | null
    receipt_status?: bigint | number | null
    block_timestamp?: Date | string | null
    block_number?: bigint | number | null
    block_hash?: string | null
    emission_by_transaction?: number | null
    emission_by_balance?: number | null
  }

  export type d_transactionUncheckedCreateInput = {
    transaction_id?: bigint | number
    hash?: string | null
    nonce?: bigint | number | null
    transaction_index?: bigint | number | null
    from_address?: string | null
    to_address?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    gas?: bigint | number | null
    gas_price?: bigint | number | null
    input?: string | null
    receipt_cumulative_gas_used?: bigint | number | null
    receipt_gas_used?: bigint | number | null
    receipt_contract_address?: string | null
    receipt_status?: bigint | number | null
    block_timestamp?: Date | string | null
    block_number?: bigint | number | null
    block_hash?: string | null
    emission_by_transaction?: number | null
    emission_by_balance?: number | null
  }

  export type d_transactionUpdateInput = {
    transaction_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transaction_index?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    from_address?: NullableStringFieldUpdateOperationsInput | string | null
    to_address?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gas?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_price?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    input?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_cumulative_gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receipt_gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receipt_contract_address?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_status?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    block_timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    block_number?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    block_hash?: NullableStringFieldUpdateOperationsInput | string | null
    emission_by_transaction?: NullableFloatFieldUpdateOperationsInput | number | null
    emission_by_balance?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type d_transactionUncheckedUpdateInput = {
    transaction_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transaction_index?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    from_address?: NullableStringFieldUpdateOperationsInput | string | null
    to_address?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gas?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_price?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    input?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_cumulative_gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receipt_gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receipt_contract_address?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_status?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    block_timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    block_number?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    block_hash?: NullableStringFieldUpdateOperationsInput | string | null
    emission_by_transaction?: NullableFloatFieldUpdateOperationsInput | number | null
    emission_by_balance?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type d_transactionCreateManyInput = {
    transaction_id?: bigint | number
    hash?: string | null
    nonce?: bigint | number | null
    transaction_index?: bigint | number | null
    from_address?: string | null
    to_address?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    gas?: bigint | number | null
    gas_price?: bigint | number | null
    input?: string | null
    receipt_cumulative_gas_used?: bigint | number | null
    receipt_gas_used?: bigint | number | null
    receipt_contract_address?: string | null
    receipt_status?: bigint | number | null
    block_timestamp?: Date | string | null
    block_number?: bigint | number | null
    block_hash?: string | null
    emission_by_transaction?: number | null
    emission_by_balance?: number | null
  }

  export type d_transactionUpdateManyMutationInput = {
    transaction_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transaction_index?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    from_address?: NullableStringFieldUpdateOperationsInput | string | null
    to_address?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gas?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_price?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    input?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_cumulative_gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receipt_gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receipt_contract_address?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_status?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    block_timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    block_number?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    block_hash?: NullableStringFieldUpdateOperationsInput | string | null
    emission_by_transaction?: NullableFloatFieldUpdateOperationsInput | number | null
    emission_by_balance?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type d_transactionUncheckedUpdateManyInput = {
    transaction_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transaction_index?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    from_address?: NullableStringFieldUpdateOperationsInput | string | null
    to_address?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gas?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_price?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    input?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_cumulative_gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receipt_gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receipt_contract_address?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_status?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    block_timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    block_number?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    block_hash?: NullableStringFieldUpdateOperationsInput | string | null
    emission_by_transaction?: NullableFloatFieldUpdateOperationsInput | number | null
    emission_by_balance?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type token_transfersCreateInput = {
    token_address?: string | null
    from_address?: string | null
    to_address?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    transaction_hash: string
    log_index: bigint | number
    block_timestamp?: Date | string | null
    block_number?: bigint | number | null
    block_hash?: string | null
  }

  export type token_transfersUncheckedCreateInput = {
    token_address?: string | null
    from_address?: string | null
    to_address?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    transaction_hash: string
    log_index: bigint | number
    block_timestamp?: Date | string | null
    block_number?: bigint | number | null
    block_hash?: string | null
  }

  export type token_transfersUpdateInput = {
    token_address?: NullableStringFieldUpdateOperationsInput | string | null
    from_address?: NullableStringFieldUpdateOperationsInput | string | null
    to_address?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transaction_hash?: StringFieldUpdateOperationsInput | string
    log_index?: BigIntFieldUpdateOperationsInput | bigint | number
    block_timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    block_number?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    block_hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type token_transfersUncheckedUpdateInput = {
    token_address?: NullableStringFieldUpdateOperationsInput | string | null
    from_address?: NullableStringFieldUpdateOperationsInput | string | null
    to_address?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transaction_hash?: StringFieldUpdateOperationsInput | string
    log_index?: BigIntFieldUpdateOperationsInput | bigint | number
    block_timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    block_number?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    block_hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type token_transfersCreateManyInput = {
    token_address?: string | null
    from_address?: string | null
    to_address?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    transaction_hash: string
    log_index: bigint | number
    block_timestamp?: Date | string | null
    block_number?: bigint | number | null
    block_hash?: string | null
  }

  export type token_transfersUpdateManyMutationInput = {
    token_address?: NullableStringFieldUpdateOperationsInput | string | null
    from_address?: NullableStringFieldUpdateOperationsInput | string | null
    to_address?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transaction_hash?: StringFieldUpdateOperationsInput | string
    log_index?: BigIntFieldUpdateOperationsInput | bigint | number
    block_timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    block_number?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    block_hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type token_transfersUncheckedUpdateManyInput = {
    token_address?: NullableStringFieldUpdateOperationsInput | string | null
    from_address?: NullableStringFieldUpdateOperationsInput | string | null
    to_address?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transaction_hash?: StringFieldUpdateOperationsInput | string
    log_index?: BigIntFieldUpdateOperationsInput | bigint | number
    block_timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    block_number?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    block_hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transactionsCreateInput = {
    hash: string
    nonce?: bigint | number | null
    transaction_index?: bigint | number | null
    from_address?: string | null
    to_address?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    gas?: bigint | number | null
    gas_price?: bigint | number | null
    input?: string | null
    receipt_cumulative_gas_used?: bigint | number | null
    receipt_gas_used?: bigint | number | null
    receipt_contract_address?: string | null
    receipt_root?: string | null
    receipt_status?: bigint | number | null
    block_timestamp?: Date | string | null
    block_number?: bigint | number | null
    block_hash?: string | null
    emission_by_transaction?: number | null
    emission_by_balance?: number | null
  }

  export type transactionsUncheckedCreateInput = {
    hash: string
    nonce?: bigint | number | null
    transaction_index?: bigint | number | null
    from_address?: string | null
    to_address?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    gas?: bigint | number | null
    gas_price?: bigint | number | null
    input?: string | null
    receipt_cumulative_gas_used?: bigint | number | null
    receipt_gas_used?: bigint | number | null
    receipt_contract_address?: string | null
    receipt_root?: string | null
    receipt_status?: bigint | number | null
    block_timestamp?: Date | string | null
    block_number?: bigint | number | null
    block_hash?: string | null
    emission_by_transaction?: number | null
    emission_by_balance?: number | null
  }

  export type transactionsUpdateInput = {
    hash?: StringFieldUpdateOperationsInput | string
    nonce?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transaction_index?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    from_address?: NullableStringFieldUpdateOperationsInput | string | null
    to_address?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gas?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_price?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    input?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_cumulative_gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receipt_gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receipt_contract_address?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_root?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_status?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    block_timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    block_number?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    block_hash?: NullableStringFieldUpdateOperationsInput | string | null
    emission_by_transaction?: NullableFloatFieldUpdateOperationsInput | number | null
    emission_by_balance?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type transactionsUncheckedUpdateInput = {
    hash?: StringFieldUpdateOperationsInput | string
    nonce?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transaction_index?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    from_address?: NullableStringFieldUpdateOperationsInput | string | null
    to_address?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gas?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_price?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    input?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_cumulative_gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receipt_gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receipt_contract_address?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_root?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_status?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    block_timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    block_number?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    block_hash?: NullableStringFieldUpdateOperationsInput | string | null
    emission_by_transaction?: NullableFloatFieldUpdateOperationsInput | number | null
    emission_by_balance?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type transactionsCreateManyInput = {
    hash: string
    nonce?: bigint | number | null
    transaction_index?: bigint | number | null
    from_address?: string | null
    to_address?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    gas?: bigint | number | null
    gas_price?: bigint | number | null
    input?: string | null
    receipt_cumulative_gas_used?: bigint | number | null
    receipt_gas_used?: bigint | number | null
    receipt_contract_address?: string | null
    receipt_root?: string | null
    receipt_status?: bigint | number | null
    block_timestamp?: Date | string | null
    block_number?: bigint | number | null
    block_hash?: string | null
    emission_by_transaction?: number | null
    emission_by_balance?: number | null
  }

  export type transactionsUpdateManyMutationInput = {
    hash?: StringFieldUpdateOperationsInput | string
    nonce?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transaction_index?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    from_address?: NullableStringFieldUpdateOperationsInput | string | null
    to_address?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gas?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_price?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    input?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_cumulative_gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receipt_gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receipt_contract_address?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_root?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_status?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    block_timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    block_number?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    block_hash?: NullableStringFieldUpdateOperationsInput | string | null
    emission_by_transaction?: NullableFloatFieldUpdateOperationsInput | number | null
    emission_by_balance?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type transactionsUncheckedUpdateManyInput = {
    hash?: StringFieldUpdateOperationsInput | string
    nonce?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transaction_index?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    from_address?: NullableStringFieldUpdateOperationsInput | string | null
    to_address?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gas?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gas_price?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    input?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_cumulative_gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receipt_gas_used?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receipt_contract_address?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_root?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_status?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    block_timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    block_number?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    block_hash?: NullableStringFieldUpdateOperationsInput | string | null
    emission_by_transaction?: NullableFloatFieldUpdateOperationsInput | number | null
    emission_by_balance?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type blocksCountOrderByAggregateInput = {
    number?: SortOrder
    hash?: SortOrder
    parent_hash?: SortOrder
    nonce?: SortOrder
    logs_bloom?: SortOrder
    transactions_root?: SortOrder
    state_root?: SortOrder
    receipts_root?: SortOrder
    fee_recipient?: SortOrder
    proposer_index?: SortOrder
    gas_limit?: SortOrder
    gas_used?: SortOrder
    timestamp?: SortOrder
    transaction_count?: SortOrder
  }

  export type blocksAvgOrderByAggregateInput = {
    number?: SortOrder
    proposer_index?: SortOrder
    gas_limit?: SortOrder
    gas_used?: SortOrder
    transaction_count?: SortOrder
  }

  export type blocksMaxOrderByAggregateInput = {
    number?: SortOrder
    hash?: SortOrder
    parent_hash?: SortOrder
    nonce?: SortOrder
    logs_bloom?: SortOrder
    transactions_root?: SortOrder
    state_root?: SortOrder
    receipts_root?: SortOrder
    fee_recipient?: SortOrder
    proposer_index?: SortOrder
    gas_limit?: SortOrder
    gas_used?: SortOrder
    timestamp?: SortOrder
    transaction_count?: SortOrder
  }

  export type blocksMinOrderByAggregateInput = {
    number?: SortOrder
    hash?: SortOrder
    parent_hash?: SortOrder
    nonce?: SortOrder
    logs_bloom?: SortOrder
    transactions_root?: SortOrder
    state_root?: SortOrder
    receipts_root?: SortOrder
    fee_recipient?: SortOrder
    proposer_index?: SortOrder
    gas_limit?: SortOrder
    gas_used?: SortOrder
    timestamp?: SortOrder
    transaction_count?: SortOrder
  }

  export type blocksSumOrderByAggregateInput = {
    number?: SortOrder
    proposer_index?: SortOrder
    gas_limit?: SortOrder
    gas_used?: SortOrder
    transaction_count?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type d_accountCountOrderByAggregateInput = {
    account_id?: SortOrder
    address?: SortOrder
    eth_sent?: SortOrder
    eth_received?: SortOrder
    account_balance?: SortOrder
  }

  export type d_accountAvgOrderByAggregateInput = {
    account_id?: SortOrder
    eth_sent?: SortOrder
    eth_received?: SortOrder
    account_balance?: SortOrder
  }

  export type d_accountMaxOrderByAggregateInput = {
    account_id?: SortOrder
    address?: SortOrder
    eth_sent?: SortOrder
    eth_received?: SortOrder
    account_balance?: SortOrder
  }

  export type d_accountMinOrderByAggregateInput = {
    account_id?: SortOrder
    address?: SortOrder
    eth_sent?: SortOrder
    eth_received?: SortOrder
    account_balance?: SortOrder
  }

  export type d_accountSumOrderByAggregateInput = {
    account_id?: SortOrder
    eth_sent?: SortOrder
    eth_received?: SortOrder
    account_balance?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type d_blockCountOrderByAggregateInput = {
    block_id?: SortOrder
    timestamp?: SortOrder
    number?: SortOrder
    hash?: SortOrder
    parent_hash?: SortOrder
    fee_recipient?: SortOrder
    logs_bloom?: SortOrder
    transactions_root?: SortOrder
    state_root?: SortOrder
    proposer_index?: SortOrder
    gas_limit?: SortOrder
    gas_used?: SortOrder
    transaction_count?: SortOrder
  }

  export type d_blockAvgOrderByAggregateInput = {
    block_id?: SortOrder
    number?: SortOrder
    proposer_index?: SortOrder
    gas_limit?: SortOrder
    gas_used?: SortOrder
    transaction_count?: SortOrder
  }

  export type d_blockMaxOrderByAggregateInput = {
    block_id?: SortOrder
    timestamp?: SortOrder
    number?: SortOrder
    hash?: SortOrder
    parent_hash?: SortOrder
    fee_recipient?: SortOrder
    logs_bloom?: SortOrder
    transactions_root?: SortOrder
    state_root?: SortOrder
    proposer_index?: SortOrder
    gas_limit?: SortOrder
    gas_used?: SortOrder
    transaction_count?: SortOrder
  }

  export type d_blockMinOrderByAggregateInput = {
    block_id?: SortOrder
    timestamp?: SortOrder
    number?: SortOrder
    hash?: SortOrder
    parent_hash?: SortOrder
    fee_recipient?: SortOrder
    logs_bloom?: SortOrder
    transactions_root?: SortOrder
    state_root?: SortOrder
    proposer_index?: SortOrder
    gas_limit?: SortOrder
    gas_used?: SortOrder
    transaction_count?: SortOrder
  }

  export type d_blockSumOrderByAggregateInput = {
    block_id?: SortOrder
    number?: SortOrder
    proposer_index?: SortOrder
    gas_limit?: SortOrder
    gas_used?: SortOrder
    transaction_count?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type d_dateCountOrderByAggregateInput = {
    date?: SortOrder
    year?: SortOrder
    month?: SortOrder
    day?: SortOrder
    weekday?: SortOrder
    day_in_chars?: SortOrder
    week?: SortOrder
  }

  export type d_dateAvgOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
    day?: SortOrder
    weekday?: SortOrder
    week?: SortOrder
  }

  export type d_dateMaxOrderByAggregateInput = {
    date?: SortOrder
    year?: SortOrder
    month?: SortOrder
    day?: SortOrder
    weekday?: SortOrder
    day_in_chars?: SortOrder
    week?: SortOrder
  }

  export type d_dateMinOrderByAggregateInput = {
    date?: SortOrder
    year?: SortOrder
    month?: SortOrder
    day?: SortOrder
    weekday?: SortOrder
    day_in_chars?: SortOrder
    week?: SortOrder
  }

  export type d_dateSumOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
    day?: SortOrder
    weekday?: SortOrder
    week?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type d_timeCountOrderByAggregateInput = {
    time?: SortOrder
    hours?: SortOrder
    minutes?: SortOrder
    seconds?: SortOrder
  }

  export type d_timeAvgOrderByAggregateInput = {
    hours?: SortOrder
    minutes?: SortOrder
    seconds?: SortOrder
  }

  export type d_timeMaxOrderByAggregateInput = {
    time?: SortOrder
    hours?: SortOrder
    minutes?: SortOrder
    seconds?: SortOrder
  }

  export type d_timeMinOrderByAggregateInput = {
    time?: SortOrder
    hours?: SortOrder
    minutes?: SortOrder
    seconds?: SortOrder
  }

  export type d_timeSumOrderByAggregateInput = {
    hours?: SortOrder
    minutes?: SortOrder
    seconds?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type d_transactionCountOrderByAggregateInput = {
    transaction_id?: SortOrder
    hash?: SortOrder
    nonce?: SortOrder
    transaction_index?: SortOrder
    from_address?: SortOrder
    to_address?: SortOrder
    value?: SortOrder
    gas?: SortOrder
    gas_price?: SortOrder
    input?: SortOrder
    receipt_cumulative_gas_used?: SortOrder
    receipt_gas_used?: SortOrder
    receipt_contract_address?: SortOrder
    receipt_status?: SortOrder
    block_timestamp?: SortOrder
    block_number?: SortOrder
    block_hash?: SortOrder
    emission_by_transaction?: SortOrder
    emission_by_balance?: SortOrder
  }

  export type d_transactionAvgOrderByAggregateInput = {
    transaction_id?: SortOrder
    nonce?: SortOrder
    transaction_index?: SortOrder
    value?: SortOrder
    gas?: SortOrder
    gas_price?: SortOrder
    receipt_cumulative_gas_used?: SortOrder
    receipt_gas_used?: SortOrder
    receipt_status?: SortOrder
    block_number?: SortOrder
    emission_by_transaction?: SortOrder
    emission_by_balance?: SortOrder
  }

  export type d_transactionMaxOrderByAggregateInput = {
    transaction_id?: SortOrder
    hash?: SortOrder
    nonce?: SortOrder
    transaction_index?: SortOrder
    from_address?: SortOrder
    to_address?: SortOrder
    value?: SortOrder
    gas?: SortOrder
    gas_price?: SortOrder
    input?: SortOrder
    receipt_cumulative_gas_used?: SortOrder
    receipt_gas_used?: SortOrder
    receipt_contract_address?: SortOrder
    receipt_status?: SortOrder
    block_timestamp?: SortOrder
    block_number?: SortOrder
    block_hash?: SortOrder
    emission_by_transaction?: SortOrder
    emission_by_balance?: SortOrder
  }

  export type d_transactionMinOrderByAggregateInput = {
    transaction_id?: SortOrder
    hash?: SortOrder
    nonce?: SortOrder
    transaction_index?: SortOrder
    from_address?: SortOrder
    to_address?: SortOrder
    value?: SortOrder
    gas?: SortOrder
    gas_price?: SortOrder
    input?: SortOrder
    receipt_cumulative_gas_used?: SortOrder
    receipt_gas_used?: SortOrder
    receipt_contract_address?: SortOrder
    receipt_status?: SortOrder
    block_timestamp?: SortOrder
    block_number?: SortOrder
    block_hash?: SortOrder
    emission_by_transaction?: SortOrder
    emission_by_balance?: SortOrder
  }

  export type d_transactionSumOrderByAggregateInput = {
    transaction_id?: SortOrder
    nonce?: SortOrder
    transaction_index?: SortOrder
    value?: SortOrder
    gas?: SortOrder
    gas_price?: SortOrder
    receipt_cumulative_gas_used?: SortOrder
    receipt_gas_used?: SortOrder
    receipt_status?: SortOrder
    block_number?: SortOrder
    emission_by_transaction?: SortOrder
    emission_by_balance?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type token_transfersTransaction_hashLog_indexCompoundUniqueInput = {
    transaction_hash: string
    log_index: bigint | number
  }

  export type token_transfersCountOrderByAggregateInput = {
    token_address?: SortOrder
    from_address?: SortOrder
    to_address?: SortOrder
    value?: SortOrder
    transaction_hash?: SortOrder
    log_index?: SortOrder
    block_timestamp?: SortOrder
    block_number?: SortOrder
    block_hash?: SortOrder
  }

  export type token_transfersAvgOrderByAggregateInput = {
    value?: SortOrder
    log_index?: SortOrder
    block_number?: SortOrder
  }

  export type token_transfersMaxOrderByAggregateInput = {
    token_address?: SortOrder
    from_address?: SortOrder
    to_address?: SortOrder
    value?: SortOrder
    transaction_hash?: SortOrder
    log_index?: SortOrder
    block_timestamp?: SortOrder
    block_number?: SortOrder
    block_hash?: SortOrder
  }

  export type token_transfersMinOrderByAggregateInput = {
    token_address?: SortOrder
    from_address?: SortOrder
    to_address?: SortOrder
    value?: SortOrder
    transaction_hash?: SortOrder
    log_index?: SortOrder
    block_timestamp?: SortOrder
    block_number?: SortOrder
    block_hash?: SortOrder
  }

  export type token_transfersSumOrderByAggregateInput = {
    value?: SortOrder
    log_index?: SortOrder
    block_number?: SortOrder
  }

  export type transactionsCountOrderByAggregateInput = {
    hash?: SortOrder
    nonce?: SortOrder
    transaction_index?: SortOrder
    from_address?: SortOrder
    to_address?: SortOrder
    value?: SortOrder
    gas?: SortOrder
    gas_price?: SortOrder
    input?: SortOrder
    receipt_cumulative_gas_used?: SortOrder
    receipt_gas_used?: SortOrder
    receipt_contract_address?: SortOrder
    receipt_root?: SortOrder
    receipt_status?: SortOrder
    block_timestamp?: SortOrder
    block_number?: SortOrder
    block_hash?: SortOrder
    emission_by_transaction?: SortOrder
    emission_by_balance?: SortOrder
  }

  export type transactionsAvgOrderByAggregateInput = {
    nonce?: SortOrder
    transaction_index?: SortOrder
    value?: SortOrder
    gas?: SortOrder
    gas_price?: SortOrder
    receipt_cumulative_gas_used?: SortOrder
    receipt_gas_used?: SortOrder
    receipt_status?: SortOrder
    block_number?: SortOrder
    emission_by_transaction?: SortOrder
    emission_by_balance?: SortOrder
  }

  export type transactionsMaxOrderByAggregateInput = {
    hash?: SortOrder
    nonce?: SortOrder
    transaction_index?: SortOrder
    from_address?: SortOrder
    to_address?: SortOrder
    value?: SortOrder
    gas?: SortOrder
    gas_price?: SortOrder
    input?: SortOrder
    receipt_cumulative_gas_used?: SortOrder
    receipt_gas_used?: SortOrder
    receipt_contract_address?: SortOrder
    receipt_root?: SortOrder
    receipt_status?: SortOrder
    block_timestamp?: SortOrder
    block_number?: SortOrder
    block_hash?: SortOrder
    emission_by_transaction?: SortOrder
    emission_by_balance?: SortOrder
  }

  export type transactionsMinOrderByAggregateInput = {
    hash?: SortOrder
    nonce?: SortOrder
    transaction_index?: SortOrder
    from_address?: SortOrder
    to_address?: SortOrder
    value?: SortOrder
    gas?: SortOrder
    gas_price?: SortOrder
    input?: SortOrder
    receipt_cumulative_gas_used?: SortOrder
    receipt_gas_used?: SortOrder
    receipt_contract_address?: SortOrder
    receipt_root?: SortOrder
    receipt_status?: SortOrder
    block_timestamp?: SortOrder
    block_number?: SortOrder
    block_hash?: SortOrder
    emission_by_transaction?: SortOrder
    emission_by_balance?: SortOrder
  }

  export type transactionsSumOrderByAggregateInput = {
    nonce?: SortOrder
    transaction_index?: SortOrder
    value?: SortOrder
    gas?: SortOrder
    gas_price?: SortOrder
    receipt_cumulative_gas_used?: SortOrder
    receipt_gas_used?: SortOrder
    receipt_status?: SortOrder
    block_number?: SortOrder
    emission_by_transaction?: SortOrder
    emission_by_balance?: SortOrder
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use blocksDefaultArgs instead
     */
    export type blocksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = blocksDefaultArgs<ExtArgs>
    /**
     * @deprecated Use d_accountDefaultArgs instead
     */
    export type d_accountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = d_accountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use d_blockDefaultArgs instead
     */
    export type d_blockArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = d_blockDefaultArgs<ExtArgs>
    /**
     * @deprecated Use d_dateDefaultArgs instead
     */
    export type d_dateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = d_dateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use d_timeDefaultArgs instead
     */
    export type d_timeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = d_timeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use d_transactionDefaultArgs instead
     */
    export type d_transactionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = d_transactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use token_transfersDefaultArgs instead
     */
    export type token_transfersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = token_transfersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use transactionsDefaultArgs instead
     */
    export type transactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = transactionsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}